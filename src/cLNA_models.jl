#=
Models to be used with the cLNA code, comparing cLNA vs. SSA
=#

SystemState = Matrix{Int64}
Moments = Vector{Int64}
Compartments = Vector{Vector{Int64}}
MomentsMap = Dict{Symbol,Int}
SigmaMap = Dict{Symbol,Tuple{Symbol,Symbol}}

Dict{Symbol,Int}(labels::Vector{Symbol}) = MomentsMap([ s=>i for (i,s) in enumerate(labels) ]...)
Dict{Symbol,Tuple{Symbol,Symbol}}(labels::Vector{Symbol}) = SigmaMap(
                                        [ s=>(s*"2",s) for s in labels ]...)


##################### IntakeExitCoagulationFragmentationBirthDeath^2(1species)

@export function IECFBDq_new(;  
                            kI=5.0, kE=0.1, 
                            kC=0.005, kF=0.005, 
                            kb=10.0, kd=0.1, λ=10.0, 
                            Ω=1.0, Ωc=1.0,
                            )
    kI, kE, kC, kF, kb, kd, λ, Ω, Ωc = float.( (kI, kE, kC, kF, kb, kd, λ, Ω, Ωc) )
    kI *= Ω; kC /= Ω
    kb *= Ωc; kd /= Ωc; kF /= Ωc
    p = Dict(:kI=>kI, :kE=>kE, :kC=>kC, :kF=>kF, :kb=>kb, :kd=>kd, :λ=>λ, 
                :Ω=>Ω, :Ωc=>Ωc,
                )
    ssaSys = getIECFBDq_newSSASystem(; kI=kI, kE=kE, kC=kC, kF=kF, kb=kb, kd=kd, λ=λ)
    labelsOde = [:N, :N2, :M¹, :M¹2, :M², :M¹M², :NM¹, :M²2, :NM²]
    momentsMapping = MomentsMap(labelsOde)
    sigmaMapping = SigmaMap([:N, :M¹])
    @show sigmaMapping #debug
    return Model(p, Ω, Ωc, IECFBDq_new_initial, IECFBDq_new_ODEs, ssaSys,
                    momentsMapping, sigmaMapping)
end

function getIECFBDq_newSSASystem(;
                            kI = 0.0, kE = 0.0,  # Intake/Exit rates for cells
                            kC = 0.0, kF = 0.0,  # Coag/Frag rates for cells
                            kb = 0.0, kd = 0.0,  # Birth/Death rates for X1
                            λ = 0,  # Parameter of the poisson distrib on intake
                            )
    S = Sim.System("IECFBDq", 1, # X1
            [:N =>[0], # Number of compartments
             :M¹ =>[1], # M¹
             :M² =>[2], # M²
            ]
            )

    # cells' reaction network
    prodX1 = Sim.new_chemical_reaction_class([1], kb)
    prodX1.H = (n::SystemState, Mom::Moments) -> Mom[1]
    prodX1.fast_sample_reactants! = fast_sample_uniform_cell

    deathX1 = Sim.new_chemical_reaction_class([-2], kd)
    deathX1.H = (n::SystemState, Mom::Moments) -> div(Mom[3]-Mom[2], 2)
    deathX1.fast_sample_reactants! = fast_sample_x1_square

    # Compartment reactions
    cellIntake = Sim.TransitionClass(0, 1, kI)
    cellIntake.H = (n::SystemState, Mom::Moments) -> 1
    # This is how the output compartment (yc) of the transition looks like
    cellIntake.pi = function(yc::Compartments, xc::Compartments)
                        yc[1][1] = rand(Poisson(λ))
                    end
    # cell_division.fast_sample_reactants! = fast_sample_cell_div

    cellExit = Sim.TransitionClass(1, 0, kE) # This is a cell death
    cellExit.H = (n::SystemState, Mom::Moments) -> Mom[1] # Depends on num cells
    cellExit.fast_sample_reactants! = fast_sample_uniform_cell

    coagulation = Sim.TransitionClass(2, 1, kC)
    coagulation.H = (n::SystemState, Mom::Moments) -> Mom[1]*(Mom[1]-1)/2
    coagulation.fast_sample_reactants! = fast_sample_uniform_2cells
    coagulation.pi = function(yc::Compartments, xc::Compartments)
                            yc[1][:] .= xc[1][:] .+ xc[2][:]
                        end

    fragmentation = Sim.TransitionClass(1, 2, kF)
    fragmentation.H = (n::SystemState, Mom::Moments) -> Mom[2]
    fragmentation.fast_sample_reactants! = fast_sample_mass_x1
    fragmentation.pi = function(yc::Compartments, xc::Compartments)
                        yc[1][1] = rand(0:xc[1][1])
                        yc[2][1] = xc[1][1] - yc[1][1]
                    end

    Sim.add_transition_class(S, prodX1, deathX1, 
        cellIntake, cellExit, coagulation, fragmentation)

    return S
end

function IECFBDq_new_ODEs(dM, M, parameters, t)
    c3 = parameters[:λ] # λ
    c0 = parameters[:kC] # kC
    c2 = parameters[:kE] # kE
    c6 = parameters[:kF] # kF
    c4 = parameters[:kI] # kI
    c5 = parameters[:kb] # kb
    c1 = parameters[:kd] # kd
    # Number of Compartments (N)
    dM[1] = c4+c6*M[3]+1/2*c0*M[1]-c2*M[1]-1/2*c0*M[2]
    # N^2
    dM[2] = c4+c2*M[1]+c6*M[3]-2*c2*M[2]+2*c0*((M[1])^(3))+2*c6*M[7]+2*c4*M[1]-1/2*c0*M[1]+3/2*c0*M[2]-3*c0*M[2]*M[1]
    # Total Mass
    dM[3] = c3*c4+c5*M[1]+c1*M[3]-c2*M[3]-c1*M[6]
    # M^2
    dM[4] = c3*c4+c2*M[6]+c4*((c3)^(2))+c5*M[1]-2*c2*M[4]-2*c1*M[5]-2*c1*M[3]+2*c5*M[7]+2*c1*M[4]+2*c1*M[6]+2*c3*c4*M[3]
    # M*S
    dM[5] = c3*c4+c4*((c3)^(3))+c5*M[7]+c5*M[9]+c5*M[1]-c0*M[5]-c1*M[8]-8*c1*M[6]-2*c0*((M[3])^(3))-2*c2*M[5]-2*c1*M[4]+2*c5*M[4]+2*c5*M[3]+3*c4*((c3)^(2))+4*c1*M[3]+5*c1*M[5]+1/3*c6*M[5]+c3*c4*M[3]+c3*c4*M[6]+c4*((c3)^(2))*M[3]-8*c1*((M[3])^(3))/((M[1])^(2))-2*c2*((M[3])^(3))/((M[1])^(2))+3*c0*M[4]*M[3]+c6*((M[3])^(2))*M[4]/((M[1])^(2))-c6*M[5]*M[3]/M[1]-6*c1*M[5]*M[3]/M[1]-2*c1*((M[3])^(3))*M[7]/((M[1])^(3))+3*c2*M[3]*M[6]/M[1]+6*c1*((M[3])^(2))*M[4]/((M[1])^(2))+12*c1*M[3]*M[6]/M[1]-1/3*c6*((M[3])^(3))*M[7]/((M[1])^(3))
    # Sum of squared content
    dM[6] = c3*c4+c0*M[4]+c4*((c3)^(2))+c5*M[1]-c0*M[6]-c2*M[6]-2*c1*M[3]+2*c5*M[3]+4*c1*M[6]+1/3*c6*M[6]+4*c1*((M[3])^(3))/((M[1])^(2))+2/3*c6*((M[3])^(3))/((M[1])^(2))-c6*M[3]*M[6]/M[1]-6*c1*M[3]*M[6]/M[1]
    # N*M
    dM[7] = c3*c4+c2*M[3]+c6*M[4]+c4*M[3]+c5*M[2]+c1*M[7]+1/2*c0*M[7]-c1*M[9]-2*c2*M[7]+c3*c4*M[1]+c0*((M[1])^(2))*M[3]-c0*M[7]*M[1]-1/2*c0*M[2]*M[3]
    # S^2
    dM[8] = c3*c4+c4*((c3)^(4))+c5*M[1]-8*c1*M[3]-4*c1*M[5]-2*c0*M[8]-2*c2*M[8]+2*c5*M[9]+4*c5*M[5]+4*c5*M[3]+4*c5*M[6]+6*c4*((c3)^(3))+7*c4*((c3)^(2))+8*c1*M[8]+24*c1*M[6]-2/15*c6*M[6]+2/3*c6*M[8]-40*c1*((M[3])^(4))/((M[1])^(3))-5*c2*((M[3])^(4))/((M[1])^(3))-4*c0*((M[3])^(2))*M[6]+2*c3*c4*M[6]+2*c0*M[4]*M[6]+2*c4*((c3)^(2))*M[6]+4*c0*M[5]*M[3]+10*c0*((M[3])^(4))/((M[1])^(3))+48*c1*((M[3])^(3))/((M[1])^(2))-6/5*c6*((M[3])^(5))/((M[1])^(4))-4/15*c6*((M[3])^(3))/((M[1])^(2))+2/3*c6*((M[3])^(4))/((M[1])^(3))-72*c1*M[3]*M[6]/M[1]-16*c0*((M[3])^(3))*M[7]/((M[1])^(3))-12*c0*((M[3])^(2))*M[6]/((M[1])^(2))-12*c1*M[8]*M[3]/M[1]-4*c1*((M[3])^(3))*M[9]/((M[1])^(3))-2*c6*M[8]*M[3]/M[1]+2*c6*((M[3])^(2))*M[5]/((M[1])^(2))+4*c0*((M[3])^(2))*M[9]/((M[1])^(2))+6*c0*((M[3])^(4))*M[2]/((M[1])^(4))+6*c2*((M[3])^(2))*M[6]/((M[1])^(2))+8*c0*((M[3])^(2))*M[4]/((M[1])^(2))+12*c1*((M[3])^(2))*M[5]/((M[1])^(2))+48*c1*((M[3])^(2))*M[6]/((M[1])^(2))-4/5*c6*((M[3])^(2))*M[6]/((M[1])^(2))-2/3*c6*((M[3])^(3))*M[9]/((M[1])^(3))+2/5*c6*M[3]*M[6]/M[1]+4/3*c6*((M[3])^(3))*M[6]/((M[1])^(3))
    # N*S
    dM[9] = c3*c4+c0*M[6]+c2*M[6]+c6*M[5]+c4*((c3)^(2))+c4*M[6]+c5*M[2]-c0*M[4]-2*c2*M[9]-2*c1*M[7]+2*c5*M[7]+4*c1*M[9]-1/2*c0*M[9]+1/3*c6*M[9]+1/3*c6*M[6]+c3*c4*M[1]+c0*((M[1])^(2))*M[6]+c0*M[4]*M[1]+c4*((c3)^(2))*M[1]-c0*M[9]*M[1]-2*c0*((M[3])^(2))*M[1]+2*c0*M[7]*M[3]-1/2*c0*M[2]*M[6]+2/3*c6*((M[3])^(3))/((M[1])^(2))+c6*((M[3])^(2))*M[7]/((M[1])^(2))-c6*M[9]*M[3]/M[1]-c6*M[3]*M[6]/M[1]-6*c1*M[9]*M[3]/M[1]-2*c1*((M[3])^(3))*M[2]/((M[1])^(3))+6*c1*((M[3])^(2))*M[7]/((M[1])^(2))-1/3*c6*((M[3])^(3))*M[2]/((M[1])^(3))
    return
end
function IECFBDq_new_initial(N0, Mpc0)
    M0 = N0*Mpc0
    MM0 = N0*Mpc0*Mpc0
    M = zeros(9)
    # Number of Compartments (N)
    M[1] = N0 # initial value for Moment(0,), please specify!
    # N^2
    M[2] = ((M[1])^(2))
    # Total Mass
    M[3] = M0 # initial value for Moment(1,), please specify!
    # M^2
    M[4] = ((M[3])^(2))
    # Sum of squared content
    M[6] = MM0 # initial value for Moment(2,), please specify!
    # M*S
    M[5] = M[3]*M[6]
    # N*M
    M[7] = M[1]*M[3]
    # S^2
    M[8] = ((M[6])^(2))
    # N*S
    M[9] = M[1]*M[6]
    return M
end

##################### IntakeExit^2CoagulationFragmentationBirthDeath^2(1species)

@export function IEqCFBDq_new(;  
                            kI=5.0, kE=0.01, 
                            kC=0.005, kF=0.005, 
                            kb=10.0, kd=0.1, λ=10.0, 
                            Ω=1.0, Ωc=1.0,
                            )
    kI, kE, kC, kF, kb, kd, λ, Ω, Ωc = float.( (kI, kE, kC, kF, kb, kd, λ, Ω, Ωc) )
    kI *= Ω; kC /= Ω
    kb *= Ωc; kd /= Ωc; kF /= Ωc
    p = Dict(:kI=>kI, :kE=>kE, :kC=>kC, :kF=>kF, :kb=>kb, :kd=>kd, :λ=>λ, 
                :Ω=>Ω, :Ωc=>Ωc,
                )
    ssaSys = getIEqCFBDq_newSSASystem(; kI=kI, kE=kE, kC=kC, kF=kF, kb=kb, kd=kd, λ=λ)
    labelsOde = [:N, :N2, :M¹, :M¹2, :NM¹, :M², :NM², :M¹M², :M²2]
    momentsMapping = MomentsMap(labelsOde)
    sigmaMapping = SigmaMap([:N, :M¹])
    @show sigmaMapping #debug
    return Model(p, Ω, Ωc, IEqCFBDq_new_initial, IEqCFBDq_new_ODEs, ssaSys,
                    momentsMapping, sigmaMapping)
end

function getIEqCFBDq_newSSASystem(;
                            kI = 0.0, kE = 0.0,  # Intake/Exit rates for cells
                            kC = 0.0, kF = 0.0,  # Coag/Frag rates for cells
                            kb = 0.0, kd = 0.0,  # Birth/Death rates for X1
                            λ = 0,  # Parameter of the poisson distrib on intake
                            )
    S = Sim.System("IECFBDq", 1, # X1
            [:N =>[0], # Number of compartments
             :M¹ =>[1], # M¹
             :M² =>[2], # M²
            ]
            )

    # cells' reaction network
    prodX1 = Sim.new_chemical_reaction_class([1], kb)
    prodX1.H = (n::SystemState, Mom::Moments) -> Mom[1]
    prodX1.fast_sample_reactants! = fast_sample_uniform_cell

    deathX1 = Sim.new_chemical_reaction_class([-2], kd)
    deathX1.H = (n::SystemState, Mom::Moments) -> div(Mom[3]-Mom[2], 2)
    deathX1.fast_sample_reactants! = fast_sample_x1_square

    # Compartment reactions
    cellIntake = Sim.TransitionClass(0, 1, kI)
    cellIntake.H = (n::SystemState, Mom::Moments) -> 1
    # This is how the output compartment (yc) of the transition looks like
    cellIntake.pi = function(yc::Compartments, xc::Compartments)
                        yc[1][1] = rand(Poisson(λ))
                    end
    # cell_division.fast_sample_reactants! = fast_sample_cell_div

    cellExit = Sim.TransitionClass(2, 1, kE) # This is a cell death
    cellExit.H = (n::SystemState, Mom::Moments) -> Mom[1]*(Mom[1]-1)/2
    cellExit.fast_sample_reactants! = fast_sample_uniform_2cells
    cellExit.pi = function(yc::Compartments, xc::Compartments)
                            yc[1][:] .= xc[1][:]
                        end

    coagulation = Sim.TransitionClass(2, 1, kC)
    coagulation.H = (n::SystemState, Mom::Moments) -> Mom[1]*(Mom[1]-1)/2
    coagulation.fast_sample_reactants! = fast_sample_uniform_2cells
    coagulation.pi = function(yc::Compartments, xc::Compartments)
                            yc[1][:] .= xc[1][:] .+ xc[2][:]
                        end

    fragmentation = Sim.TransitionClass(1, 2, kF)
    fragmentation.H = (n::SystemState, Mom::Moments) -> Mom[2]
    fragmentation.fast_sample_reactants! = fast_sample_mass_x1
    fragmentation.pi = function(yc::Compartments, xc::Compartments)
                        yc[1][1] = rand(0:xc[1][1])
                        yc[2][1] = xc[1][1] - yc[1][1]
                    end

    Sim.add_transition_class(S, prodX1, deathX1, 
        cellIntake, cellExit, coagulation, fragmentation)

    return S
end

function IEqCFBDq_new_ODEs(dM, M, parameters, t)
    c0 = parameters[:λ] # λ
    c5 = parameters[:kC] # kC
    c2 = parameters[:kE] # kE
    c1 = parameters[:kF] # kF
    c4 = parameters[:kI] # kI
    c3 = parameters[:kb] # kb
    c6 = parameters[:kd] # kd
    # Number of Compartments (N)
    dM[1] = c4+c1*M[3]+1/2*c5*M[1]+1/2*c2*M[1]-1/2*c5*M[2]-1/2*c2*M[2]
    # N^2
    dM[2] = c4+c1*M[3]+2*c5*((M[1])^(3))+2*c2*((M[1])^(3))+2*c1*M[6]+2*c4*M[1]-1/2*c5*M[1]-1/2*c2*M[1]+3/2*c5*M[2]+3/2*c2*M[2]-3*c5*M[2]*M[1]-3*c2*M[2]*M[1]
    # Total Mass
    dM[3] = c0*c4+c3*M[1]+c6*M[3]+1/2*c2*M[3]-c6*M[7]-1/2*c2*M[6]
    # M^2
    dM[4] = c0*c4+c2*M[4]+c4*((c0)^(2))+c3*M[1]+1/2*c2*M[5]-2*c6*M[8]-2*c6*M[3]+2*c3*M[6]+2*c6*M[4]+2*c6*M[7]-1/2*c2*M[7]-c2*M[4]*M[1]-2*c2*M[6]*M[3]+2*c0*c4*M[3]+2*c2*((M[3])^(2))*M[1]
    # N*S
    dM[5] = c0*c4+c5*M[7]+c1*M[8]+c4*((c0)^(2))+c4*M[7]+c3*M[2]-c5*M[4]-2*c6*M[6]+2*c3*M[6]+4*c6*M[5]-1/2*c5*M[5]-1/2*c2*M[7]+1/3*c1*M[5]+1/3*c1*M[7]+3/2*c2*M[5]+c0*c4*M[1]+c5*((M[1])^(2))*M[7]+c5*M[4]*M[1]+c4*((c0)^(2))*M[1]-c5*M[5]*M[1]-c2*M[2]*M[7]-2*c5*((M[3])^(2))*M[1]-2*c2*M[5]*M[1]+2*c5*M[6]*M[3]+2*c2*((M[1])^(2))*M[7]-1/2*c5*M[2]*M[7]+2/3*c1*((M[3])^(3))/((M[1])^(2))+c1*((M[3])^(2))*M[6]/((M[1])^(2))-c1*M[5]*M[3]/M[1]-c1*M[3]*M[7]/M[1]-6*c6*M[5]*M[3]/M[1]-2*c6*((M[3])^(3))*M[2]/((M[1])^(3))+6*c6*((M[3])^(2))*M[6]/((M[1])^(2))-1/3*c1*((M[3])^(3))*M[2]/((M[1])^(3))
    # N*M
    dM[6] = c0*c4+c1*M[4]+c4*M[3]+c3*M[2]+c6*M[6]+1/2*c5*M[6]-c6*M[5]-1/2*c2*M[3]+3/2*c2*M[6]+c0*c4*M[1]+c5*((M[1])^(2))*M[3]-c5*M[6]*M[1]-c2*M[2]*M[3]-2*c2*M[6]*M[1]+2*c2*((M[1])^(2))*M[3]-1/2*c5*M[2]*M[3]
    # Sum of squared content
    dM[7] = c0*c4+c5*M[4]+c4*((c0)^(2))+c3*M[1]+1/2*c2*M[7]-c5*M[7]-2*c6*M[3]+2*c3*M[3]+4*c6*M[7]-1/2*c2*M[5]+1/3*c1*M[7]+4*c6*((M[3])^(3))/((M[1])^(2))+2/3*c1*((M[3])^(3))/((M[1])^(2))-c1*M[3]*M[7]/M[1]-6*c6*M[3]*M[7]/M[1]
    # M*S
    dM[8] = c0*c4+c2*M[8]+c4*((c0)^(3))+c3*M[6]+c3*M[5]+c3*M[1]-c5*M[8]-c6*M[9]-8*c6*M[7]-2*c5*((M[3])^(3))-2*c6*M[4]+2*c3*M[4]+2*c3*M[3]+3*c4*((c0)^(2))+4*c6*M[3]+5*c6*M[8]+1/3*c1*M[8]+c0*c4*M[3]+c0*c4*M[7]+c2*((M[3])^(3))/((M[1])^(2))+c4*((c0)^(2))*M[3]-c2*M[6]*M[7]-c2*M[5]*M[3]-c2*M[8]*M[1]-8*c6*((M[3])^(3))/((M[1])^(2))+3*c5*M[4]*M[3]+c1*((M[3])^(2))*M[4]/((M[1])^(2))+1/2*c2*((M[3])^(3))*M[2]/((M[1])^(3))-c1*M[8]*M[3]/M[1]-6*c6*M[8]*M[3]/M[1]-2*c6*((M[3])^(3))*M[6]/((M[1])^(3))+2*c2*M[1]*M[3]*M[7]+6*c6*((M[3])^(2))*M[4]/((M[1])^(2))+12*c6*M[3]*M[7]/M[1]-3/2*c2*M[3]*M[7]/M[1]-3/2*c2*((M[3])^(2))*M[6]/((M[1])^(2))-1/3*c1*((M[3])^(3))*M[6]/((M[1])^(3))+3/2*c2*M[5]*M[3]/M[1]
    # S^2
    dM[9] = c0*c4+c2*M[9]+c4*((c0)^(4))+c3*M[1]-8*c6*M[3]-4*c6*M[8]-2*c5*M[9]+2*c3*M[5]+4*c3*M[8]+4*c3*M[3]+4*c3*M[7]+6*c4*((c0)^(3))+7*c4*((c0)^(2))+8*c6*M[9]+24*c6*M[7]-2/15*c1*M[7]+2/3*c1*M[9]-c2*M[9]*M[1]-40*c6*((M[3])^(4))/((M[1])^(3))-4*c5*((M[3])^(2))*M[7]-2*c2*M[5]*M[7]+2*c0*c4*M[7]+2*c5*M[4]*M[7]+2*c2*((M[7])^(2))*M[1]+2*c4*((c0)^(2))*M[7]+4*c5*M[8]*M[3]+10*c5*((M[3])^(4))/((M[1])^(3))+48*c6*((M[3])^(3))/((M[1])^(2))-6/5*c1*((M[3])^(5))/((M[1])^(4))-4/15*c1*((M[3])^(3))/((M[1])^(2))+2/3*c1*((M[3])^(4))/((M[1])^(3))+5/2*c2*((M[3])^(4))/((M[1])^(3))-72*c6*M[3]*M[7]/M[1]-16*c5*((M[3])^(3))*M[6]/((M[1])^(3))-12*c5*((M[3])^(2))*M[7]/((M[1])^(2))-12*c6*M[9]*M[3]/M[1]-4*c2*((M[3])^(3))*M[6]/((M[1])^(3))-4*c6*((M[3])^(3))*M[5]/((M[1])^(3))-3*c2*((M[3])^(2))*M[7]/((M[1])^(2))-2*c1*M[9]*M[3]/M[1]+2*c1*((M[3])^(2))*M[8]/((M[1])^(2))+3*c2*((M[3])^(2))*M[5]/((M[1])^(2))+4*c5*((M[3])^(2))*M[5]/((M[1])^(2))+6*c5*((M[3])^(4))*M[2]/((M[1])^(4))+8*c5*((M[3])^(2))*M[4]/((M[1])^(2))+12*c6*((M[3])^(2))*M[8]/((M[1])^(2))+48*c6*((M[3])^(2))*M[7]/((M[1])^(2))-4/5*c1*((M[3])^(2))*M[7]/((M[1])^(2))-2/3*c1*((M[3])^(3))*M[5]/((M[1])^(3))+2/5*c1*M[3]*M[7]/M[1]+3/2*c2*((M[3])^(4))*M[2]/((M[1])^(4))+4/3*c1*((M[3])^(3))*M[7]/((M[1])^(3))
    return
end
function IEqCFBDq_new_initial(N0, Mpc0)
    M0 = N0*Mpc0
    MM0 = N0*Mpc0*Mpc0
    M = zeros(9)
    # Number of Compartments (N)
    M[1] = N0 # initial value for Moment(0,), please specify!
    # N^2
    M[2] = ((M[1])^(2))
    # Total Mass
    M[3] = M0 # initial value for Moment(1,), please specify!
    # M^2
    M[4] = ((M[3])^(2))
    # N*M
    M[6] = M[1]*M[3]
    # Sum of squared content
    M[7] = MM0 # initial value for Moment(2,), please specify!
    # N*S
    M[5] = M[1]*M[7]
    # M*S
    M[8] = M[3]*M[7]
    # S^2
    M[9] = ((M[7])^(2))
    return M
end

##################### IntakeExitCoagulationFragmentationMMBirthDeath(1species)

@export function IECFmmBD_new(;  
                            kI=5.0, kE=0.1, 
                            kC=0.005, kF=0.1,
                            kM=10.0, 
                            kb=10.0, kd=0.1, λ=10.0, 
                            Ω=1.0, Ωc=1.0,
                            )
    kI, kE, kC, kF, kM, kb, kd, λ, Ω, Ωc = float.( (kI, kE, kC, kF, kM, kb, kd, λ, Ω, Ωc) )
    kI *= Ω; kC /= Ω
    kb *= Ωc; kd /= Ωc; kF /= Ωc; kM /= Ωc
    p = Dict(:kI=>kI, :kE=>kE, :kC=>kC, :kF=>kF, :kM=>kM, :kb=>kb, :kd=>kd, :λ=>λ, 
                :Ω=>Ω, :Ωc=>Ωc,
                )
    ssaSys = getIECFmmBD_newSSASystem(; kI=kI, kE=kE, kC=kC, kF=kF, kM=kM, kb=kb, kd=kd, λ=λ)
    labelsOde = [:N, :N2, :M¹, :M¹2, :NM¹, :M², :NM², :M²2, :M¹M²]
    momentsMapping = MomentsMap(labelsOde)
    sigmaMapping = SigmaMap([:N, :M¹])
    @show sigmaMapping #debug
    return Model(p, Ω, Ωc, IECFmmBD_new_initial, IECFmmBD_new_ODEs, ssaSys,
                    momentsMapping, sigmaMapping)
end

function getIECFmmBD_newSSASystem(;
                            kI = 0.0, kE = 0.0,  # Intake/Exit rates for cells
                            kC = 0.0, kF = 0.0,  # Coag/Frag rates for cells
                            kM = 0.0,
                            kb = 0.0, kd = 0.0,  # Birth/Death rates for X1
                            λ = 0,  # Parameter of the poisson distrib on intake
                            )
    S = Sim.System("IECFmmBD", 1, # X1
            [:N =>[0], # Number of compartments
             :M¹ =>[1], # M¹
             :M² =>[2], # M²
            ]
            )

    # cells' reaction network
    prodX1 = Sim.new_chemical_reaction_class([1], kb)
    prodX1.H = (n::SystemState, Mom::Moments) -> Mom[1]
    prodX1.fast_sample_reactants! = fast_sample_uniform_cell

    deathX1 = Sim.new_chemical_reaction_class([-1], kd)
    deathX1.g = (xc::Compartments, Mom::Moments) -> xc[1][1]

    # Compartment reactions
    cellIntake = Sim.TransitionClass(0, 1, kI)
    cellIntake.H = (n::SystemState, Mom::Moments) -> 1
    # This is how the output compartment (yc) of the transition looks like
    cellIntake.pi = function(yc::Compartments, xc::Compartments)
                        yc[1][1] = rand(Poisson(λ))
                    end
    # cell_division.fast_sample_reactants! = fast_sample_cell_div

    cellExit = Sim.TransitionClass(1, 0, kE) # This is a cell death
    cellExit.H = (n::SystemState, Mom::Moments) -> Mom[1] # Depends on num cells
    cellExit.fast_sample_reactants! = fast_sample_uniform_cell

    coagulation = Sim.TransitionClass(2, 1, kC)
    coagulation.H = (n::SystemState, Mom::Moments) -> Mom[1]*(Mom[1]-1)/2
    coagulation.fast_sample_reactants! = fast_sample_uniform_2cells
    coagulation.pi = function(yc::Compartments, xc::Compartments)
                            yc[1][:] .= xc[1][:] .+ xc[2][:]
                        end

    fragmentation = Sim.TransitionClass(1, 2, kF)
    fragmentation.g = (xc::Compartments, Mom::Moments) -> xc[1][1]/(xc[1][1]+kM)
    fragmentation.pi = function(yc::Compartments, xc::Compartments)
                        yc[1][1] = rand(0:xc[1][1])
                        yc[2][1] = xc[1][1] - yc[1][1]
                    end

    Sim.add_transition_class(S, prodX1, deathX1, 
        cellIntake, cellExit, coagulation, fragmentation)

    return S
end

function IECFmmBD_new_ODEs(dM, M, parameters, t)
    c4 = parameters[:λ] # λ
    c0 = parameters[:kM] # kM
    c6 = parameters[:kC] # kC
    c7 = parameters[:kE] # kE
    c2 = parameters[:kF] # kF
    c1 = parameters[:kI] # kI
    c3 = parameters[:kb] # kb
    c5 = parameters[:kd] # kd
    # Number of Compartments (N)
    dM[1] = c1+1/2*c6*M[1]-c7*M[1]-1/2*c6*M[2]+c2*M[3]/(c0+M[3]/M[1])+c2*((M[3])^(2))/(((c0)^(2))*M[1]+((M[3])^(2))/M[1]+2*c0*M[3])-c2*M[7]/(((c0)^(2))+((M[3])^(2))/((M[1])^(2))+2*c0*M[3]/M[1])-2*c2*((M[3])^(3))/(((c0)^(3))*((M[1])^(2))+((M[3])^(3))/M[1]+3*c0*((M[3])^(2))+3*((c0)^(2))*M[1]*M[3])+c2*((M[3])^(3))*M[1]/(((M[3])^(3))+((c0)^(3))*((M[1])^(3))+3*c0*((M[3])^(2))*M[1]+3*((c0)^(2))*((M[1])^(2))*M[3])+c2*M[3]*M[7]/(((c0)^(3))*M[1]+((M[3])^(3))/((M[1])^(2))+3*((c0)^(2))*M[3]+3*c0*((M[3])^(2))/M[1])
    # N^2
    dM[2] = c1+c7*M[1]-2*c7*M[2]+2*c6*((M[1])^(3))+2*c1*M[1]-1/2*c6*M[1]+3/2*c6*M[2]+c2*M[3]/(c0+M[3]/M[1])+c2*((M[3])^(2))/(((c0)^(2))*M[1]+((M[3])^(2))/M[1]+2*c0*M[3])-c2*M[7]/(((c0)^(2))+((M[3])^(2))/((M[1])^(2))+2*c0*M[3]/M[1])-3*c6*M[2]*M[1]-2*c2*M[6]/(((c0)^(2))+((M[3])^(2))/((M[1])^(2))+2*c0*M[3]/M[1])-2*c2*((M[3])^(3))/(((c0)^(3))*((M[1])^(2))+((M[3])^(3))/M[1]+3*c0*((M[3])^(2))+3*((c0)^(2))*M[1]*M[3])+2*c2*M[5]/(c0+M[3]/M[1])+c2*((M[3])^(3))*M[1]/(((M[3])^(3))+((c0)^(3))*((M[1])^(3))+3*c0*((M[3])^(2))*M[1]+3*((c0)^(2))*((M[1])^(2))*M[3])+c2*M[3]*M[7]/(((c0)^(3))*M[1]+((M[3])^(3))/((M[1])^(2))+3*((c0)^(2))*M[3]+3*c0*((M[3])^(2))/M[1])-4*c2*((M[3])^(2))*M[5]/(((c0)^(3))*((M[1])^(2))+((M[3])^(3))/M[1]+3*c0*((M[3])^(2))+3*((c0)^(2))*M[1]*M[3])+2*c2*M[5]*M[3]/(((c0)^(2))*M[1]+((M[3])^(2))/M[1]+2*c0*M[3])+2*c2*((M[3])^(3))*M[2]/(((M[3])^(3))+((c0)^(3))*((M[1])^(3))+3*c0*((M[3])^(2))*M[1]+3*((c0)^(2))*((M[1])^(2))*M[3])+2*c2*M[6]*M[3]/(((c0)^(3))*M[1]+((M[3])^(3))/((M[1])^(2))+3*((c0)^(2))*M[3]+3*c0*((M[3])^(2))/M[1])
    # Total Mass
    dM[3] = c4*c1+c3*M[1]-c7*M[3]-c5*M[3]
    # M^2
    dM[4] = c4*c1+c7*M[7]+c1*((c4)^(2))+c3*M[1]+c5*M[3]-2*c7*M[4]-2*c5*M[4]+2*c3*M[5]+2*c4*c1*M[3]
    # N*M
    dM[5] = c4*c1+c7*M[3]+c1*M[3]+c3*M[2]+1/2*c6*M[5]-c5*M[5]-2*c7*M[5]+c4*c1*M[1]+c6*((M[1])^(2))*M[3]+c2*M[4]/(c0+M[3]/M[1])-c6*M[5]*M[1]-c2*M[9]/(((c0)^(2))+((M[3])^(2))/((M[1])^(2))+2*c0*M[3]/M[1])-1/2*c6*M[2]*M[3]+c2*M[4]*M[3]/(((c0)^(2))*M[1]+((M[3])^(2))/M[1]+2*c0*M[3])+c2*((M[3])^(3))*M[5]/(((M[3])^(3))+((c0)^(3))*((M[1])^(3))+3*c0*((M[3])^(2))*M[1]+3*((c0)^(2))*((M[1])^(2))*M[3])+c2*M[9]*M[3]/(((c0)^(3))*M[1]+((M[3])^(3))/((M[1])^(2))+3*((c0)^(2))*M[3]+3*c0*((M[3])^(2))/M[1])-2*c2*((M[3])^(2))*M[4]/(((c0)^(3))*((M[1])^(2))+((M[3])^(3))/M[1]+3*c0*((M[3])^(2))+3*((c0)^(2))*M[1]*M[3])
    # N*S
    dM[6] = c4*c1+c6*M[7]+c7*M[7]+c1*((c4)^(2))+c1*M[7]+c3*M[2]+c5*M[5]-c6*M[4]-2*c7*M[6]-2*c5*M[6]+2*c3*M[5]-1/2*c6*M[6]+c4*c1*M[1]+c6*((M[1])^(2))*M[7]+c6*M[4]*M[1]+c2*M[9]/(c0+M[3]/M[1])+c2*M[6]/(3*c0+3*M[3]/M[1])+c2*M[7]/(3*c0+3*M[3]/M[1])+c1*((c4)^(2))*M[1]-c6*M[6]*M[1]-c2*M[8]/(((c0)^(2))+((M[3])^(2))/((M[1])^(2))+2*c0*M[3]/M[1])-3*c2*((M[3])^(3))/(3*c0*((M[1])^(2))+3*M[1]*M[3])-3*c2*((M[3])^(3))/(9*((M[3])^(2))+9*((c0)^(2))*((M[1])^(2))+18*c0*M[1]*M[3])-2*c6*((M[3])^(2))*M[1]-2*c2*((M[3])^(4))/(((c0)^(2))*((M[1])^(3))+((M[3])^(2))*M[1]+2*c0*((M[1])^(2))*M[3])-2*c2*((M[3])^(4))/(3*((M[3])^(3))+3*((c0)^(3))*((M[1])^(3))+9*c0*((M[3])^(2))*M[1]+9*((c0)^(2))*((M[1])^(2))*M[3])+2*c6*M[5]*M[3]+2*c2*((M[3])^(3))/(c0*((M[1])^(2))+M[1]*M[3])+2*c2*((M[3])^(5))/(3*((c0)^(3))*((M[1])^(4))+3*((M[3])^(3))*M[1]+9*c0*((M[1])^(2))*((M[3])^(2))+9*((c0)^(2))*((M[1])^(3))*M[3])+3*c2*((M[3])^(4))/(9*((c0)^(2))*((M[1])^(3))+9*((M[3])^(2))*M[1]+18*c0*((M[1])^(2))*M[3])+4*c2*((M[3])^(3))/(3*((M[3])^(2))+3*((c0)^(2))*((M[1])^(2))+6*c0*M[1]*M[3])-1/2*c6*M[2]*M[7]+c2*((M[3])^(2))*M[5]/(c0*((M[1])^(2))+M[1]*M[3])+c2*((M[3])^(3))*M[1]/(c0*((M[1])^(2))+M[1]*M[3])+c2*((M[3])^(2))*M[5]/(((M[3])^(2))+((c0)^(2))*((M[1])^(2))+2*c0*M[1]*M[3])+c2*((M[3])^(2))*M[6]/(((M[3])^(2))+((c0)^(2))*((M[1])^(2))+2*c0*M[1]*M[3])+c2*((M[3])^(2))*M[7]/(((M[3])^(2))+((c0)^(2))*((M[1])^(2))+2*c0*M[1]*M[3])+c2*((M[1])^(2))*((M[3])^(4))/(((c0)^(2))*((M[1])^(4))+((M[1])^(2))*((M[3])^(2))+2*c0*((M[1])^(3))*M[3])+c2*((M[3])^(4))*M[1]/(((c0)^(2))*((M[1])^(4))+((M[1])^(2))*((M[3])^(2))+2*c0*((M[1])^(3))*M[3])+c2*M[9]*M[3]/(((c0)^(2))*M[1]+((M[3])^(2))/M[1]+2*c0*M[3])+c2*((M[3])^(3))*M[6]/(((M[3])^(3))+((c0)^(3))*((M[1])^(3))+3*c0*((M[3])^(2))*M[1]+3*((c0)^(2))*((M[1])^(2))*M[3])+c2*M[8]*M[3]/(((c0)^(3))*M[1]+((M[3])^(3))/((M[1])^(2))+3*((c0)^(2))*M[3]+3*c0*((M[3])^(2))/M[1])+c2*((M[3])^(2))*M[6]/(3*((c0)^(3))*((M[1])^(2))+3*((M[3])^(3))/M[1]+9*c0*((M[3])^(2))+9*((c0)^(2))*M[1]*M[3])+c2*((M[3])^(2))*M[7]/(3*((c0)^(3))*((M[1])^(2))+3*((M[3])^(3))/M[1]+9*c0*((M[3])^(2))+9*((c0)^(2))*M[1]*M[3])+c2*((M[1])^(2))*((M[3])^(4))/(3*((c0)^(3))*((M[1])^(4))+3*((M[3])^(3))*M[1]+9*c0*((M[1])^(2))*((M[3])^(2))+9*((c0)^(2))*((M[1])^(3))*M[3])+c2*((M[3])^(4))*M[2]/(3*((c0)^(3))*((M[1])^(4))+3*((M[3])^(3))*M[1]+9*c0*((M[1])^(2))*((M[3])^(2))+9*((c0)^(2))*((M[1])^(3))*M[3])+c2*((M[3])^(4))*M[1]/(3*((c0)^(3))*((M[1])^(4))+3*((M[3])^(3))*M[1]+9*c0*((M[1])^(2))*((M[3])^(2))+9*((c0)^(2))*((M[1])^(3))*M[3])+c2*((M[3])^(5))*M[1]/(3*((c0)^(3))*((M[1])^(4))+3*((M[3])^(3))*M[1]+9*c0*((M[1])^(2))*((M[3])^(2))+9*((c0)^(2))*((M[1])^(3))*M[3])-c2*((M[1])^(2))*((M[3])^(3))/(c0*((M[1])^(3))+((M[1])^(2))*M[3])-c2*((M[3])^(3))*M[1]/(c0*((M[1])^(3))+((M[1])^(2))*M[3])-c2*M[6]*M[3]/(c0*M[1]+M[3])-c2*M[3]*M[7]/(c0*M[1]+M[3])-c2*((M[3])^(3))*M[2]/(3*c0*((M[1])^(3))+3*((M[1])^(2))*M[3])-c2*((M[3])^(3))*M[1]/(((M[3])^(2))+((c0)^(2))*((M[1])^(2))+2*c0*M[1]*M[3])-c2*((M[3])^(3))*M[2]/(3*((c0)^(2))*((M[1])^(3))+3*((M[3])^(2))*M[1]+6*c0*((M[1])^(2))*M[3])-c2*((M[3])^(3))*M[6]/(3*((M[3])^(3))+3*((c0)^(3))*((M[1])^(3))+9*c0*((M[3])^(2))*M[1]+9*((c0)^(2))*((M[1])^(2))*M[3])-c2*((M[3])^(3))*M[7]/(3*((M[3])^(3))+3*((c0)^(3))*((M[1])^(3))+9*c0*((M[3])^(2))*M[1]+9*((c0)^(2))*((M[1])^(2))*M[3])-c2*((M[3])^(4))*M[1]/(3*((M[3])^(3))+3*((c0)^(3))*((M[1])^(3))+9*c0*((M[3])^(2))*M[1]+9*((c0)^(2))*((M[1])^(2))*M[3])-c2*((M[1])^(2))*((M[3])^(5))/(3*((c0)^(3))*((M[1])^(5))+3*((M[1])^(2))*((M[3])^(3))+9*c0*((M[1])^(3))*((M[3])^(2))+9*((c0)^(2))*((M[1])^(4))*M[3])-c2*((M[3])^(5))*M[2]/(3*((c0)^(3))*((M[1])^(5))+3*((M[1])^(2))*((M[3])^(3))+9*c0*((M[1])^(3))*((M[3])^(2))+9*((c0)^(2))*((M[1])^(4))*M[3])-c2*((M[3])^(5))*M[1]/(3*((c0)^(3))*((M[1])^(5))+3*((M[1])^(2))*((M[3])^(3))+9*c0*((M[1])^(3))*((M[3])^(2))+9*((c0)^(2))*((M[1])^(4))*M[3])-5*c2*((M[3])^(3))*M[5]/(3*((c0)^(2))*((M[1])^(3))+3*((M[3])^(2))*M[1]+6*c0*((M[1])^(2))*M[3])-3*c2*((M[3])^(3))*M[1]/(9*((M[3])^(2))+9*((c0)^(2))*((M[1])^(2))+18*c0*M[1]*M[3])-3*c2*((M[1])^(2))*((M[3])^(4))/(9*((c0)^(2))*((M[1])^(4))+9*((M[1])^(2))*((M[3])^(2))+18*c0*((M[1])^(3))*M[3])-3*c2*((M[3])^(4))*M[1]/(9*((c0)^(2))*((M[1])^(4))+9*((M[1])^(2))*((M[3])^(2))+18*c0*((M[1])^(3))*M[3])-2*c2*((M[3])^(3))*M[1]/(3*c0*((M[1])^(2))+3*M[1]*M[3])-2*c2*((M[3])^(4))*M[1]/(((c0)^(2))*((M[1])^(3))+((M[3])^(2))*M[1]+2*c0*((M[1])^(2))*M[3])-2*c2*((M[1])^(2))*((M[3])^(3))/(3*((c0)^(2))*((M[1])^(3))+3*((M[3])^(2))*M[1]+6*c0*((M[1])^(2))*M[3])-2*c2*((M[3])^(3))*M[1]/(3*((c0)^(2))*((M[1])^(3))+3*((M[3])^(2))*M[1]+6*c0*((M[1])^(2))*M[3])-2*c2*M[6]*M[3]/(3*((c0)^(2))*M[1]+3*((M[3])^(2))/M[1]+6*c0*M[3])-2*c2*M[3]*M[7]/(3*((c0)^(2))*M[1]+3*((M[3])^(2))/M[1]+6*c0*M[3])-2*c2*((M[3])^(3))*M[5]/(3*((M[3])^(3))+3*((c0)^(3))*((M[1])^(3))+9*c0*((M[3])^(2))*M[1]+9*((c0)^(2))*((M[1])^(2))*M[3])-2*c2*((M[3])^(2))*M[9]/(((c0)^(3))*((M[1])^(2))+((M[3])^(3))/M[1]+3*c0*((M[3])^(2))+3*((c0)^(2))*M[1]*M[3])+2*c2*((M[1])^(2))*((M[3])^(3))/(3*c0*((M[1])^(3))+3*((M[1])^(2))*M[3])+2*c2*((M[3])^(3))*M[1]/(3*c0*((M[1])^(3))+3*((M[1])^(2))*M[3])+2*c2*((M[3])^(4))*M[2]/(3*((c0)^(2))*((M[1])^(4))+3*((M[1])^(2))*((M[3])^(2))+6*c0*((M[1])^(3))*M[3])+2*c2*((M[3])^(4))*M[5]/(3*((c0)^(3))*((M[1])^(4))+3*((M[3])^(3))*M[1]+9*c0*((M[1])^(2))*((M[3])^(2))+9*((c0)^(2))*((M[1])^(3))*M[3])+3*c2*((M[3])^(4))*M[1]/(3*((c0)^(2))*((M[1])^(3))+3*((M[3])^(2))*M[1]+6*c0*((M[1])^(2))*M[3])+3*c2*((M[1])^(2))*((M[3])^(3))/(9*((c0)^(2))*((M[1])^(3))+9*((M[3])^(2))*M[1]+18*c0*((M[1])^(2))*M[3])+3*c2*((M[3])^(3))*M[1]/(9*((c0)^(2))*((M[1])^(3))+9*((M[3])^(2))*M[1]+18*c0*((M[1])^(2))*M[3])+3*c2*((M[3])^(4))*M[1]/(9*((c0)^(2))*((M[1])^(3))+9*((M[3])^(2))*M[1]+18*c0*((M[1])^(2))*M[3])+5*c2*((M[3])^(3))*M[1]/(3*((M[3])^(2))+3*((c0)^(2))*((M[1])^(2))+6*c0*M[1]*M[3])
    # Sum of squared content
    dM[7] = c4*c1+c6*M[4]+c1*((c4)^(2))+c3*M[1]+c5*M[3]-c6*M[7]-c7*M[7]-2*c5*M[7]+2*c3*M[3]+c2*M[7]/(3*c0+3*M[3]/M[1])-3*c2*((M[3])^(3))/(3*c0*((M[1])^(2))+3*M[1]*M[3])-3*c2*((M[3])^(3))/(9*((M[3])^(2))+9*((c0)^(2))*((M[1])^(2))+18*c0*M[1]*M[3])-2*c2*((M[3])^(4))/(((c0)^(2))*((M[1])^(3))+((M[3])^(2))*M[1]+2*c0*((M[1])^(2))*M[3])-2*c2*((M[3])^(4))/(3*((M[3])^(3))+3*((c0)^(3))*((M[1])^(3))+9*c0*((M[3])^(2))*M[1]+9*((c0)^(2))*((M[1])^(2))*M[3])+2*c2*((M[3])^(3))/(c0*((M[1])^(2))+M[1]*M[3])+2*c2*((M[3])^(5))/(3*((c0)^(3))*((M[1])^(4))+3*((M[3])^(3))*M[1]+9*c0*((M[1])^(2))*((M[3])^(2))+9*((c0)^(2))*((M[1])^(3))*M[3])+3*c2*((M[3])^(4))/(9*((c0)^(2))*((M[1])^(3))+9*((M[3])^(2))*M[1]+18*c0*((M[1])^(2))*M[3])+4*c2*((M[3])^(3))/(3*((M[3])^(2))+3*((c0)^(2))*((M[1])^(2))+6*c0*M[1]*M[3])+c2*((M[3])^(2))*M[7]/(((M[3])^(2))+((c0)^(2))*((M[1])^(2))+2*c0*M[1]*M[3])+c2*((M[3])^(4))*M[1]/(((c0)^(2))*((M[1])^(4))+((M[1])^(2))*((M[3])^(2))+2*c0*((M[1])^(3))*M[3])+c2*((M[3])^(2))*M[7]/(3*((c0)^(3))*((M[1])^(2))+3*((M[3])^(3))/M[1]+9*c0*((M[3])^(2))+9*((c0)^(2))*M[1]*M[3])+c2*((M[3])^(4))*M[1]/(3*((c0)^(3))*((M[1])^(4))+3*((M[3])^(3))*M[1]+9*c0*((M[1])^(2))*((M[3])^(2))+9*((c0)^(2))*((M[1])^(3))*M[3])-c2*((M[3])^(3))*M[1]/(c0*((M[1])^(3))+((M[1])^(2))*M[3])-c2*M[3]*M[7]/(c0*M[1]+M[3])-c2*((M[3])^(3))*M[7]/(3*((M[3])^(3))+3*((c0)^(3))*((M[1])^(3))+9*c0*((M[3])^(2))*M[1]+9*((c0)^(2))*((M[1])^(2))*M[3])-c2*((M[3])^(5))*M[1]/(3*((c0)^(3))*((M[1])^(5))+3*((M[1])^(2))*((M[3])^(3))+9*c0*((M[1])^(3))*((M[3])^(2))+9*((c0)^(2))*((M[1])^(4))*M[3])-3*c2*((M[3])^(4))*M[1]/(9*((c0)^(2))*((M[1])^(4))+9*((M[1])^(2))*((M[3])^(2))+18*c0*((M[1])^(3))*M[3])-2*c2*((M[3])^(3))*M[1]/(3*((c0)^(2))*((M[1])^(3))+3*((M[3])^(2))*M[1]+6*c0*((M[1])^(2))*M[3])-2*c2*M[3]*M[7]/(3*((c0)^(2))*M[1]+3*((M[3])^(2))/M[1]+6*c0*M[3])+2*c2*((M[3])^(3))*M[1]/(3*c0*((M[1])^(3))+3*((M[1])^(2))*M[3])+3*c2*((M[3])^(3))*M[1]/(9*((c0)^(2))*((M[1])^(3))+9*((M[3])^(2))*M[1]+18*c0*((M[1])^(2))*M[3])
    # S^2
    dM[8] = c4*c1+c1*((c4)^(4))+c3*M[1]+c5*M[3]-4*c5*M[8]-4*c5*M[7]-2*c6*M[8]-2*c7*M[8]+2*c3*M[6]+2*c5*M[9]+4*c3*M[9]+4*c3*M[3]+4*c3*M[7]+6*c1*((c4)^(3))+7*c1*((c4)^(2))-30*c2*((M[3])^(5))/(15*c0*((M[1])^(4))+15*((M[1])^(3))*M[3])-30*c2*((M[3])^(4))/(225*((c0)^(2))*((M[1])^(3))+225*((M[3])^(2))*M[1]+450*c0*((M[1])^(2))*M[3])-30*c2*((M[3])^(6))/(225*((c0)^(2))*((M[1])^(5))+225*((M[1])^(3))*((M[3])^(2))+450*c0*((M[1])^(4))*M[3])-16*c2*((M[3])^(5))/(15*((c0)^(2))*((M[1])^(4))+15*((M[1])^(2))*((M[3])^(2))+30*c0*((M[1])^(3))*M[3])-8*c2*((M[3])^(3))/(15*((M[3])^(2))+15*((c0)^(2))*((M[1])^(2))+30*c0*M[1]*M[3])-8*c5*((M[3])^(3))/((M[1])^(2))-6*c2*((M[3])^(3))/(15*c0*((M[1])^(2))+15*M[1]*M[3])-5*c7*((M[3])^(4))/((M[1])^(3))-4*c6*((M[3])^(2))*M[7]-4*c2*((M[3])^(5))/(15*((c0)^(3))*((M[1])^(4))+15*((M[3])^(3))*M[1]+45*c0*((M[1])^(2))*((M[3])^(2))+45*((c0)^(2))*((M[1])^(3))*M[3])-4*c2*((M[3])^(7))/(15*((c0)^(3))*((M[1])^(6))+15*((M[1])^(3))*((M[3])^(3))+45*c0*((M[1])^(4))*((M[3])^(2))+45*((c0)^(2))*((M[1])^(5))*M[3])-2*c2*M[7]/(15*c0+15*M[3]/M[1])+2*c4*c1*M[7]+2*c6*M[4]*M[7]+2*c2*M[8]/(3*c0+3*M[3]/M[1])+2*c1*((c4)^(2))*M[7]+4*c6*M[9]*M[3]+4*c2*((M[3])^(4))/(15*((M[3])^(3))+15*((c0)^(3))*((M[1])^(3))+45*c0*((M[3])^(2))*M[1]+45*((c0)^(2))*((M[1])^(2))*M[3])+4*c2*((M[3])^(6))/(15*((c0)^(3))*((M[1])^(5))+15*((M[1])^(2))*((M[3])^(3))+45*c0*((M[1])^(3))*((M[3])^(2))+45*((c0)^(2))*((M[1])^(4))*M[3])+10*c6*((M[3])^(4))/((M[1])^(3))+12*c2*((M[3])^(4))/(15*((c0)^(2))*((M[1])^(3))+15*((M[3])^(2))*M[1]+30*c0*((M[1])^(2))*M[3])+16*c2*((M[3])^(4))/(15*c0*((M[1])^(3))+15*((M[1])^(2))*M[3])+20*c2*((M[3])^(6))/(15*((c0)^(2))*((M[1])^(5))+15*((M[1])^(3))*((M[3])^(2))+30*c0*((M[1])^(4))*M[3])+30*c2*((M[3])^(3))/(225*((M[3])^(2))+225*((c0)^(2))*((M[1])^(2))+450*c0*M[1]*M[3])+30*c2*((M[3])^(5))/(225*((c0)^(2))*((M[1])^(4))+225*((M[1])^(2))*((M[3])^(2))+450*c0*((M[1])^(3))*M[3])-30*c2*((M[3])^(3))*M[1]/(225*((c0)^(2))*((M[1])^(3))+225*((M[3])^(2))*M[1]+450*c0*((M[1])^(2))*M[3])-30*c2*((M[3])^(5))*M[1]/(225*((c0)^(2))*((M[1])^(5))+225*((M[1])^(3))*((M[3])^(2))+450*c0*((M[1])^(4))*M[3])-16*c6*((M[3])^(3))*M[5]/((M[1])^(3))-12*c6*((M[3])^(2))*M[7]/((M[1])^(2))-12*c2*((M[3])^(2))*M[7]/(15*c0*((M[1])^(2))+15*M[1]*M[3])-10*c2*((M[3])^(3))*M[9]/(3*((c0)^(2))*((M[1])^(3))+3*((M[3])^(2))*M[1]+6*c0*((M[1])^(2))*M[3])-10*c2*((M[3])^(4))*M[7]/(15*((c0)^(2))*((M[1])^(4))+15*((M[1])^(2))*((M[3])^(2))+30*c0*((M[1])^(3))*M[3])-10*c2*((M[3])^(6))*M[1]/(15*((c0)^(2))*((M[1])^(6))+15*((M[1])^(4))*((M[3])^(2))+30*c0*((M[1])^(5))*M[3])-6*c2*((M[3])^(3))*M[7]/(3*c0*((M[1])^(2))+3*M[1]*M[3])-6*c2*((M[3])^(4))*M[1]/(15*c0*((M[1])^(4))+15*((M[1])^(3))*M[3])-6*c2*((M[3])^(3))*M[7]/(9*((M[3])^(2))+9*((c0)^(2))*((M[1])^(2))+18*c0*M[1]*M[3])-6*c2*((M[3])^(2))*M[7]/(15*((M[3])^(2))+15*((c0)^(2))*((M[1])^(2))+30*c0*M[1]*M[3])-6*c2*((M[3])^(4))*M[1]/(15*((c0)^(2))*((M[1])^(4))+15*((M[1])^(2))*((M[3])^(2))+30*c0*((M[1])^(3))*M[3])-4*c2*((M[3])^(4))*M[7]/(((c0)^(2))*((M[1])^(3))+((M[3])^(2))*M[1]+2*c0*((M[1])^(2))*M[3])-4*c2*M[8]*M[3]/(3*((c0)^(2))*M[1]+3*((M[3])^(2))/M[1]+6*c0*M[3])-4*c2*((M[3])^(3))*M[9]/(3*((M[3])^(3))+3*((c0)^(3))*((M[1])^(3))+9*c0*((M[3])^(2))*M[1]+9*((c0)^(2))*((M[1])^(2))*M[3])-2*c2*M[8]*M[3]/(c0*M[1]+M[3])-2*c2*((M[3])^(3))*M[6]/(3*c0*((M[1])^(3))+3*((M[1])^(2))*M[3])-2*c2*((M[3])^(3))*M[7]/(((M[3])^(2))+((c0)^(2))*((M[1])^(2))+2*c0*M[1]*M[3])-2*c2*((M[3])^(3))*M[6]/(3*((c0)^(2))*((M[1])^(3))+3*((M[3])^(2))*M[1]+6*c0*((M[1])^(2))*M[3])-2*c2*((M[3])^(3))*M[8]/(3*((M[3])^(3))+3*((c0)^(3))*((M[1])^(3))+9*c0*((M[3])^(2))*M[1]+9*((c0)^(2))*((M[1])^(2))*M[3])-2*c2*((M[3])^(5))*M[6]/(3*((c0)^(3))*((M[1])^(5))+3*((M[1])^(2))*((M[3])^(3))+9*c0*((M[1])^(3))*((M[3])^(2))+9*((c0)^(2))*((M[1])^(4))*M[3])-2*c2*((M[3])^(2))*M[7]/(15*((c0)^(3))*((M[1])^(2))+15*((M[3])^(3))/M[1]+45*c0*((M[3])^(2))+45*((c0)^(2))*M[1]*M[3])-2*c2*((M[3])^(4))*M[1]/(15*((c0)^(3))*((M[1])^(4))+15*((M[3])^(3))*M[1]+45*c0*((M[1])^(2))*((M[3])^(2))+45*((c0)^(2))*((M[1])^(3))*M[3])-2*c2*((M[3])^(4))*M[7]/(15*((c0)^(3))*((M[1])^(4))+15*((M[3])^(3))*M[1]+45*c0*((M[1])^(2))*((M[3])^(2))+45*((c0)^(2))*((M[1])^(3))*M[3])-2*c2*((M[3])^(6))*M[1]/(15*((c0)^(3))*((M[1])^(6))+15*((M[1])^(3))*((M[3])^(3))+45*c0*((M[1])^(4))*((M[3])^(2))+45*((c0)^(2))*((M[1])^(5))*M[3])+2*c2*((M[3])^(2))*M[9]/(c0*((M[1])^(2))+M[1]*M[3])+2*c2*((M[3])^(3))*M[7]/(c0*((M[1])^(2))+M[1]*M[3])+2*c2*((M[3])^(3))*M[1]/(15*c0*((M[1])^(3))+15*((M[1])^(2))*M[3])+2*c2*((M[3])^(2))*M[8]/(((M[3])^(2))+((c0)^(2))*((M[1])^(2))+2*c0*M[1]*M[3])+2*c2*((M[3])^(2))*M[9]/(((M[3])^(2))+((c0)^(2))*((M[1])^(2))+2*c0*M[1]*M[3])+2*c2*((M[3])^(3))*M[7]/(15*((M[3])^(3))+15*((c0)^(3))*((M[1])^(3))+45*c0*((M[3])^(2))*M[1]+45*((c0)^(2))*((M[1])^(2))*M[3])+2*c2*((M[3])^(2))*M[8]/(3*((c0)^(3))*((M[1])^(2))+3*((M[3])^(3))/M[1]+9*c0*((M[3])^(2))+9*((c0)^(2))*M[1]*M[3])+2*c2*((M[3])^(4))*M[6]/(3*((c0)^(3))*((M[1])^(4))+3*((M[3])^(3))*M[1]+9*c0*((M[1])^(2))*((M[3])^(2))+9*((c0)^(2))*((M[1])^(3))*M[3])+2*c2*((M[3])^(5))*M[1]/(15*((c0)^(3))*((M[1])^(5))+15*((M[1])^(2))*((M[3])^(3))+45*c0*((M[1])^(3))*((M[3])^(2))+45*((c0)^(2))*((M[1])^(4))*M[3])+2*c2*((M[3])^(5))*M[7]/(15*((c0)^(3))*((M[1])^(5))+15*((M[1])^(2))*((M[3])^(3))+45*c0*((M[1])^(3))*((M[3])^(2))+45*((c0)^(2))*((M[1])^(4))*M[3])+2*c2*((M[3])^(7))*M[1]/(15*((c0)^(3))*((M[1])^(7))+15*((M[1])^(4))*((M[3])^(3))+45*c0*((M[1])^(5))*((M[3])^(2))+45*((c0)^(2))*((M[1])^(6))*M[3])+4*c6*((M[3])^(2))*M[6]/((M[1])^(2))+4*c2*((M[3])^(4))*M[6]/(3*((c0)^(2))*((M[1])^(4))+3*((M[1])^(2))*((M[3])^(2))+6*c0*((M[1])^(3))*M[3])+4*c2*((M[3])^(3))*M[1]/(15*((c0)^(2))*((M[1])^(3))+15*((M[3])^(2))*M[1]+30*c0*((M[1])^(2))*M[3])+4*c2*M[3]*M[7]/(15*((c0)^(2))*M[1]+15*((M[3])^(2))/M[1]+30*c0*M[3])+4*c2*((M[3])^(4))*M[9]/(3*((c0)^(3))*((M[1])^(4))+3*((M[3])^(3))*M[1]+9*c0*((M[1])^(2))*((M[3])^(2))+9*((c0)^(2))*((M[1])^(3))*M[3])+6*c6*((M[3])^(4))*M[2]/((M[1])^(4))+6*c7*((M[3])^(2))*M[7]/((M[1])^(2))+6*c2*M[3]*M[7]/(15*M[3]+15*c0*M[1])+6*c2*((M[3])^(4))*M[7]/(9*((c0)^(2))*((M[1])^(3))+9*((M[3])^(2))*M[1]+18*c0*((M[1])^(2))*M[3])+8*c6*((M[3])^(2))*M[4]/((M[1])^(2))+8*c2*((M[3])^(3))*M[7]/(3*((M[3])^(2))+3*((c0)^(2))*((M[1])^(2))+6*c0*M[1]*M[3])+8*c2*((M[3])^(3))*M[7]/(15*((c0)^(2))*((M[1])^(3))+15*((M[3])^(2))*M[1]+30*c0*((M[1])^(2))*M[3])+8*c2*((M[3])^(5))*M[1]/(15*((c0)^(2))*((M[1])^(5))+15*((M[1])^(3))*((M[3])^(2))+30*c0*((M[1])^(4))*M[3])+10*c2*((M[3])^(4))*M[7]/(3*((c0)^(2))*((M[1])^(3))+3*((M[3])^(2))*M[1]+6*c0*((M[1])^(2))*M[3])+12*c2*((M[3])^(5))*M[1]/(15*c0*((M[1])^(5))+15*((M[1])^(4))*M[3])+12*c5*M[3]*M[7]/M[1]+20*c2*((M[3])^(3))*M[7]/(15*c0*((M[1])^(3))+15*((M[1])^(2))*M[3])+30*c2*((M[3])^(4))*M[1]/(225*((c0)^(2))*((M[1])^(4))+225*((M[1])^(2))*((M[3])^(2))+450*c0*((M[1])^(3))*M[3])+30*c2*((M[3])^(6))*M[1]/(225*((c0)^(2))*((M[1])^(6))+225*((M[1])^(4))*((M[3])^(2))+450*c0*((M[1])^(5))*M[3])-6*c2*((M[3])^(4))*M[1]*M[7]/(9*((c0)^(2))*((M[1])^(4))+9*((M[1])^(2))*((M[3])^(2))+18*c0*((M[1])^(3))*M[3])-4*c2*((M[3])^(4))*M[1]*M[7]/(3*((c0)^(2))*((M[1])^(4))+3*((M[1])^(2))*((M[3])^(2))+6*c0*((M[1])^(3))*M[3])-2*c2*((M[3])^(3))*M[1]*M[7]/(c0*((M[1])^(3))+((M[1])^(2))*M[3])-2*c2*((M[3])^(3))*M[1]*M[7]/(3*((c0)^(2))*((M[1])^(3))+3*((M[3])^(2))*M[1]+6*c0*((M[1])^(2))*M[3])+2*c2*((M[3])^(4))*M[1]*M[7]/(((c0)^(2))*((M[1])^(4))+((M[1])^(2))*((M[3])^(2))+2*c0*((M[1])^(3))*M[3])+6*c2*((M[3])^(3))*M[1]*M[7]/(3*c0*((M[1])^(3))+3*((M[1])^(2))*M[3])+6*c2*((M[3])^(3))*M[1]*M[7]/(9*((c0)^(2))*((M[1])^(3))+9*((M[3])^(2))*M[1]+18*c0*((M[1])^(2))*M[3])
    # M*S
    dM[9] = c4*c1+c1*((c4)^(3))+c3*M[5]+c3*M[6]+c3*M[1]+c5*M[4]-c6*M[9]-c5*M[3]-3*c5*M[9]-2*c6*((M[3])^(3))-2*c7*M[9]+2*c3*M[4]+2*c3*M[3]+2*c5*M[7]+3*c1*((c4)^(2))+c4*c1*M[3]+c4*c1*M[7]+c2*M[9]/(3*c0+3*M[3]/M[1])+c2*((M[3])^(4))/(3*((M[3])^(2))+3*((c0)^(2))*((M[1])^(2))+6*c0*M[1]*M[3])+c1*((c4)^(2))*M[3]-c2*((M[3])^(5))/(3*((c0)^(2))*((M[1])^(3))+3*((M[3])^(2))*M[1]+6*c0*((M[1])^(2))*M[3])-3*c2*((M[3])^(4))/(9*((M[3])^(2))+9*((c0)^(2))*((M[1])^(2))+18*c0*M[1]*M[3])-2*c7*((M[3])^(3))/((M[1])^(2))+3*c6*M[4]*M[3]+3*c2*((M[3])^(5))/(9*((c0)^(2))*((M[1])^(3))+9*((M[3])^(2))*M[1]+18*c0*((M[1])^(2))*M[3])+c2*((M[3])^(2))*M[4]/(c0*((M[1])^(2))+M[1]*M[3])+c2*((M[3])^(2))*M[4]/(((M[3])^(2))+((c0)^(2))*((M[1])^(2))+2*c0*M[1]*M[3])+c2*((M[3])^(2))*M[9]/(((M[3])^(2))+((c0)^(2))*((M[1])^(2))+2*c0*M[1]*M[3])+c2*((M[3])^(5))*M[1]/(((c0)^(2))*((M[1])^(4))+((M[1])^(2))*((M[3])^(2))+2*c0*((M[1])^(3))*M[3])+c2*((M[3])^(2))*M[9]/(3*((c0)^(3))*((M[1])^(2))+3*((M[3])^(3))/M[1]+9*c0*((M[3])^(2))+9*((c0)^(2))*M[1]*M[3])+c2*((M[3])^(4))*M[5]/(3*((c0)^(3))*((M[1])^(4))+3*((M[3])^(3))*M[1]+9*c0*((M[1])^(2))*((M[3])^(2))+9*((c0)^(2))*((M[1])^(3))*M[3])-c2*((M[3])^(4))*M[1]/(c0*((M[1])^(3))+((M[1])^(2))*M[3])-c2*M[9]*M[3]/(c0*M[1]+M[3])-c2*((M[3])^(3))*M[5]/(3*c0*((M[1])^(3))+3*((M[1])^(2))*M[3])-c2*((M[3])^(3))*M[5]/(3*((c0)^(2))*((M[1])^(3))+3*((M[3])^(2))*M[1]+6*c0*((M[1])^(2))*M[3])-c2*((M[3])^(4))*M[1]/(3*((c0)^(2))*((M[1])^(3))+3*((M[3])^(2))*M[1]+6*c0*((M[1])^(2))*M[3])-c2*((M[3])^(3))*M[9]/(3*((M[3])^(3))+3*((c0)^(3))*((M[1])^(3))+9*c0*((M[3])^(2))*M[1]+9*((c0)^(2))*((M[1])^(2))*M[3])-c2*((M[3])^(5))*M[5]/(3*((c0)^(3))*((M[1])^(5))+3*((M[1])^(2))*((M[3])^(3))+9*c0*((M[1])^(3))*((M[3])^(2))+9*((c0)^(2))*((M[1])^(4))*M[3])-5*c2*((M[3])^(3))*M[4]/(3*((c0)^(2))*((M[1])^(3))+3*((M[3])^(2))*M[1]+6*c0*((M[1])^(2))*M[3])-3*c2*((M[3])^(5))*M[1]/(9*((c0)^(2))*((M[1])^(4))+9*((M[1])^(2))*((M[3])^(2))+18*c0*((M[1])^(3))*M[3])-2*c2*((M[3])^(5))*M[1]/(3*((c0)^(2))*((M[1])^(4))+3*((M[1])^(2))*((M[3])^(2))+6*c0*((M[1])^(3))*M[3])-2*c2*M[9]*M[3]/(3*((c0)^(2))*M[1]+3*((M[3])^(2))/M[1]+6*c0*M[3])-2*c2*((M[3])^(3))*M[4]/(3*((M[3])^(3))+3*((c0)^(3))*((M[1])^(3))+9*c0*((M[3])^(2))*M[1]+9*((c0)^(2))*((M[1])^(2))*M[3])+2*c2*((M[3])^(4))*M[5]/(3*((c0)^(2))*((M[1])^(4))+3*((M[1])^(2))*((M[3])^(2))+6*c0*((M[1])^(3))*M[3])+2*c2*((M[3])^(4))*M[4]/(3*((c0)^(3))*((M[1])^(4))+3*((M[3])^(3))*M[1]+9*c0*((M[1])^(2))*((M[3])^(2))+9*((c0)^(2))*((M[1])^(3))*M[3])+3*c7*M[3]*M[7]/M[1]+3*c2*((M[3])^(4))*M[1]/(3*c0*((M[1])^(3))+3*((M[1])^(2))*M[3])+3*c2*((M[3])^(4))*M[1]/(9*((c0)^(2))*((M[1])^(3))+9*((M[3])^(2))*M[1]+18*c0*((M[1])^(2))*M[3])
    return
end
function IECFmmBD_new_initial(N0, Mpc0)
    M0 = N0*Mpc0
    MM0 = N0*Mpc0*Mpc0
    M = zeros(9)
    # Number of Compartments (N)
    M[1] = N0 # initial value for Moment(0,), please specify!
    # N^2
    M[2] = ((M[1])^(2))
    # Total Mass
    M[3] = M0 # initial value for Moment(1,), please specify!
    # M^2
    M[4] = ((M[3])^(2))
    # N*M
    M[5] = M[1]*M[3]
    # Sum of squared content
    M[7] = MM0 # initial value for Moment(2,), please specify!
    # N*S
    M[6] = M[1]*M[7]
    # S^2
    M[8] = ((M[7])^(2))
    # M*S
    M[9] = M[3]*M[7]
    return M
end

################################## END new ###############

##################### Smoluchowski
const s = 20.
@export function Smoluchowski(; kC=1.0,
                                Ω=1.0, Ωc=1.0,
                                )
    kC, Ω, Ωc = float.( (kC, Ω, Ωc) )
    kC /= Ω
    p = Dict(:kC=>kC)
    momentsMapping = MomentsMap([   :N, :N2,
                                    :M¹, :M¹2,
                                    :M², :NM¹,  ])
    sigmaMapping = SigmaMap( [:N, :M¹] )
    ssaSys = getSmoluchowskiSSASystem(; kC=kC )
    # return Model(p, Ω, Ωc, Smoluchowski_initial, 
    #                        # Smoluchowski_ODEs_sum, 
    #                        Smoluchowski_ODEs_mult, 
    #                        # Smoluchowski_ODEs_freeMolecular, 
    #                        # Smoluchowski_ODEs_gelationTest, 
    #                        ssaSys)
    return Model(p, Ω, Ωc, Smoluchowski_initial_var, 
                           # Smoluchowski_ODEs_sum_var, 
                           Smoluchowski_ODEs_mult_var, 
                           ssaSys,
                           momentsMapping, sigmaMapping,
                           )
end

_freeMolecularKernel(x,y) = ( x^(1/3) + y^(1/3) )^2 * sqrt( (1/x) + (1/y) )
_gelationTestKernel(x,y) = sqrt( (x^2 * y) + (x * y^2) ) * ( x^(1/3) + y^(1/3) )

function getSmoluchowskiSSASystem(;
                            kC=1.,
                            )
    S = Sim.System("Smoluchowski", 1, # X1
            [:N =>[0], # Number of compartments
             :M¹ =>[1], # M¹
             :M² =>[2], # M²
            ]
            )

    coagulation = Sim.TransitionClass(2, 1, kC)
    # coagulation.g = (xc::Compartments, Mom::Moments) -> xc[1][1] + xc[2][1]
    coagulation.g = (xc::Compartments, Mom::Moments) -> xc[1][1] * xc[2][1]
    # coagulation.g = (xc::Compartments, Mom::Moments) -> _freeMolecularKernel(xc[1][1], xc[2][1])
    # coagulation.g = (xc::Compartments, Mom::Moments) -> _gelationTestKernel(xc[1][1], xc[2][1])
    coagulation.pi = function(yc::Compartments, xc::Compartments)
                            yc[1][:] .= xc[1][:] .+ xc[2][:]
                        end

    Sim.add_transition_class(S, coagulation)
    return S
end

function Smoluchowski_ODEs_sum(dM, M, parameters, t)
    c0 = parameters[:kC] # kC
    # Number of Compartments (N)
    dM[1] = c0*(1-M[1])*M[3]
    # N^2
    dM[2] = c0*(-M[3]+2*M[5]+M[1]*M[3]-2*M[2]*M[3]-2*M[5]*M[1]+2*((M[1])^(2))*M[3])
    # Total Mass
    dM[3] = 0
    # M^2
    dM[4] = 0
    # N*M
    dM[5] = c0*(((M[3])^(2))*M[1]-M[4]*M[1]-M[5]*M[3]+M[4])
    return
end
function Smoluchowski_ODEs_sum_var(dM, M, parameters, t)
    c0 = parameters[:kC] # kC
    # Number of Compartments (N)
    dM[1] = c0*(1-M[1])*M[3]
    # N^2
    dM[2] = c0*(-M[3]+2*M[6]+M[1]*M[3]-2*M[2]*M[3]-2*M[6]*M[1]+2*((M[1])^(2))*M[3])
    # Total Mass
    dM[3] = 0
    # M^2
    dM[4] = 0
    # Sum of squared content
    dM[5] = 2*c0*((M[3])^(3))*(-1+M[1])/((M[1])^(2))
    # N*M
    dM[6] = c0*(((M[3])^(2))*M[1]-M[4]*M[1]-M[6]*M[3]+M[4])
    return
end
function Smoluchowski_ODEs_mult(dM, M, parameters, t)
    c0 = parameters[:kC] # kC
    # Number of Compartments (N)
    dM[1] = c0*(1-M[1])*M[3]
    # N^2
    dM[2] = c0*(-M[3]+2*M[5]+M[1]*M[3]-2*M[2]*M[3]-2*M[5]*M[1]+2*M[1]^2*M[3])
    # Total Mass
    dM[3] = 0
    # M^2
    dM[4] = 0
    # N*M
    dM[5] = c0*(M[3]^2*M[1]-M[4]*M[1]-M[5]*M[3]+M[4])
    return
end
function Smoluchowski_ODEs_mult_var(dM, M, parameters, t)
    c0 = parameters[:kC] # kC
    # Number of Compartments (N)
    dM[1] = 1/2*c0*((M[3])^(2))*(1-M[1])/M[1]
    # N^2
    dM[2] = 1/2*c0*(((M[1])^(2))*(-4*M[6]+2*M[1]*M[3]+M[3])+(-M[3]+4*M[6])*M[1]-2*M[2]*M[3])*M[3]/((M[1])^(2))
    # Total Mass
    dM[3] = 0
    # M^2
    dM[4] = 0
    # Sum of squared content
    dM[5] = c0*((M[3])^(4))*(-1+M[1])/((M[1])^(3))
    # N*M
    dM[6] = 1/2*c0*(((M[1])^(2))*(((M[3])^(2))-2*M[4])-M[6]*M[3]+2*M[4]*M[1])*M[3]/((M[1])^(2))
    return
end
function Smoluchowski_ODEs_freeMolecular(dM, M, parameters, t)
    c0 = parameters[:kC] # kC
    # Number of Compartments (N)
    dM[1] = -1/4*c0*((2)^(1/2))*((M[1])^(5))*((((M[3]/M[1]))^(0.333333333333333))*(-5.33333333333333+10.6666666666667*M[1])*M[3]+(((M[3]/M[1]))^(0.666666666666665))*(1.00000000000000*(((M[3]/M[1]))^(0.666666666666667))-9.00000000000000*(((M[3]/M[1]))^(0.666666666666666))-(((M[3]/M[1]))^(0.666666666666667))*M[1]+9*(((M[3]/M[1]))^(0.666666666666666))*M[1])*M[1]-(((M[3]/M[1]))^(0.333333333333332))*(-5.33333333333333+10.6666666666667*M[1])*M[3])/((((M[3]/M[1]))^(0.666666666666665))*(((M[1]/M[3]))^(9/2))*((M[3])^(5)))
    # N^2
    dM[2] = 1/4*c0*((2)^(1/2))*((((M[3]/M[1]))^(5.66666666666667))*((M[1])^(3))*((((M[3]/M[1]))^(0.666666666666667))*M[3]+(-(((M[3]/M[1]))^(0.666666666666667))*M[3]+2*(((M[3]/M[1]))^(0.666666666666667))*M[5]+9*(((M[3]/M[1]))^(0.666666666666666))*M[3])*M[1]-2.00000000000000*(((M[3]/M[1]))^(0.666666666666667))*M[5]-9.00000000000000*(((M[3]/M[1]))^(0.666666666666666))*M[3]-36*(((M[3]/M[1]))^(0.666666666666666))*M[2]*M[3]+2*(((M[3]/M[1]))^(0.666666666666667))*M[2]*M[3])+((M[1])^(2))*((((M[3]/M[1]))^(5.33333333333333))*(10.6666666666667*M[5]-5.33333333333333*M[3]+10.6666666666667*M[2]*M[3])+18.0000000000000*(((M[3]/M[1]))^(6.33333333333333))*M[2]+(((M[3]/M[1]))^(5.33333333333333))*(5.33333333333333*M[3]-10.6666666666667*M[5])*M[1]+2*(((M[3]/M[1]))^(5.66666666666667))*((M[1])^(3))*(-(((M[3]/M[1]))^(0.666666666666667))+9*(((M[3]/M[1]))^(0.666666666666666))))*M[3]+((M[3])^(2))*(-(((M[3]/M[1]))^(4.33333333333333))*(6.00000000000000*M[5]+6*M[2]*M[3])+5.33333333333333*(((M[3]/M[1]))^(5.33333333333333))*M[1]-5.33333333333333*(((M[3]/M[1]))^(5.33333333333333))*((M[1])^(2))-10.6666666666667*(((M[3]/M[1]))^(5.33333333333333))*M[2]+6*(((M[3]/M[1]))^(4.33333333333333))*M[5]*M[1])*M[1]+6.00000000000000*(((M[3]/M[1]))^(4.33333333333333))*((M[3])^(3))*M[2])/((((M[3]/M[1]))^(5.66666666666667))*(((M[1]/M[3]))^(3/2))*((M[3])^(3)))
    # Total Mass
    dM[3] = 0
    # M^2
    dM[4] = 0
    # N*M
    dM[5] = c0*((2)^(1/2))*(((M[1])^(2))*((((M[3]/M[1]))^(4.66666666666667))*(2.25000000000000*(((M[3]/M[1]))^(0.666666666666666))*M[5]+((M[1])^(2))*(2.25000000000000*(((M[3]/M[1]))^(0.666666666666666))-0.250000000000000*(((M[3]/M[1]))^(0.666666666666667)))*M[3]+0.250000000000000*(((M[3]/M[1]))^(0.666666666666667))*M[5]*M[1]-4.50000000000000*(((M[3]/M[1]))^(0.666666666666666))*M[5]*M[1])+1.33333333333333*(((M[3]/M[1]))^(4.33333333333333))*(M[5]*M[3]-M[4]*M[1]+M[4]))*M[3]+((M[3])^(2))*(-0.750000000000000*(((M[3]/M[1]))^(3.33333333333333))*(M[5]*M[3]+M[4])-1.33333333333333*(((M[3]/M[1]))^(4.33333333333333))*M[5]+0.750000000000000*(((M[3]/M[1]))^(3.33333333333333))*M[4]*M[1])*M[1]+0.750000000000000*(((M[3]/M[1]))^(3.33333333333333))*((M[3])^(3))*M[5]+0.250000000000000*(((M[3]/M[1]))^(5.33333333333333))*((M[1])^(3))*(-1+M[1])*M[4])/((((M[3]/M[1]))^(4.66666666666667))*(((M[1]/M[3]))^(3/2))*((M[3])^(3)))
    return
end
function Smoluchowski_ODEs_gelationTest(dM, M, parameters, t)
    c0 = parameters[:kC] # kC
    # Number of Compartments (N)
    dM[1] = -c0*((2)^(1/2))*(((M[3]/M[1]))^(0.333333333333333))*(((((M[3])^(3))/((M[1])^(3))))^(3/2))*((M[1])^(4))*(-1.00000000000000+M[1])/((M[3])^(3))
    # N^2
    dM[2] = -c0*((2)^(1/2))*(((((M[3])^(3))/((M[1])^(3))))^(3/2))*((M[1])^(2))*((((M[3]/M[1]))^(1.66666666666667))*((M[1])^(2))*(-3.00000000000000+3*M[1])*M[5]+(((M[3]/M[1]))^(1.66666666666667))*(-((M[1])^(2))-2*((M[1])^(3))+1.00000000000000*M[2]+1.00000000000000*M[1]+M[2]*M[1])*M[1]*M[3]-0.666666666666667*(((M[3]/M[1]))^(0.666666666666667))*((M[3])^(2))*(-1+M[1])*M[2]+0.666666666666667*(((M[3]/M[1]))^(0.666666666666667))*(-1+M[1])*M[5]*M[1]*M[3])/((((M[3]/M[1]))^(1.33333333333333))*((M[3])^(4)))
    # Total Mass
    dM[3] = 0
    # M^2
    dM[4] = 0
    # N*M
    dM[5] = 1/2*c0*((2)^(1/2))*((M[3])^(2))*(-((((M[3]/M[1]))^(1.66666666666667))*(1.00000000000000+M[1])*M[5]+0.666666666666667*(((M[3]/M[1]))^(0.666666666666667))*(-1+M[1])*M[4])*M[1]*M[3]+2*(((M[3]/M[1]))^(1.66666666666667))*((M[1])^(3))*((M[3])^(2))-(((M[3]/M[1]))^(1.66666666666667))*((M[1])^(2))*(-3.00000000000000+3*M[1])*M[4]+0.666666666666667*(((M[3]/M[1]))^(0.666666666666667))*((M[3])^(2))*(-1+M[1])*M[5])/((((M[3]/M[1]))^(1.33333333333333))*(((((M[3])^(3))/((M[1])^(3))))^(1/2))*((M[1])^(4)))
    return
end

# initialize expected moments vector
function Smoluchowski_initial(N0, Mpc0)
    M0 = N0*Mpc0
    M = zeros(5)
    # Number of Compartments (N)
    M[1] = N0 # initial value for Moment(0,), please specify!
    # N^2
    M[2] = M[1]^2
    # Total Mass
    M[3] = M0 # initial value for Moment(1,), please specify!
    # M^2
    M[4] = M[3]^2
    # N*M
    M[5] = M[1]*M[3]
    return M
end
function Smoluchowski_initial_var(N0, Mpc0)
    M0 = N0*Mpc0
    M = zeros(6)
    # Number of Compartments (N)
    M[1] = N0 # initial value for Moment(0,), please specify!
    # N^2
    M[2] = M[1]^2
    # Total Mass
    M[3] = M0 # initial value for Moment(1,), please specify!
    # M^2
    M[4] = M[3]^2
    # Sum of squared content
    M[5] = M0 # initial value for Moment(2,), please specify!
    # N*M
    M[6] = M[1]*M[3]
    return M
end

##################### SimpleSwitch
const s = 20.
@export function SimpleSwitch(; kb=100.0*s, kl=0.1,
                                kM=10., h=8., 
                                kd=4.40*s,
                                kI=0.0, λ=5.0,
                                kE=0.1, kD=0.25, # Works pretty well
                                # kE=0.01, kD=0.025, # Ugly ugly
                                Ω=1.0, Ωc=1.0,
                                )
    kb, kl, kM, h, kd, kI, λ, kE, kD, Ω, Ωc = float.( (kb, kl, kM, h, kd, kI, λ, kE, kD, Ω, Ωc) )
    kb *= Ωc
    kI *= Ω
    kE /= Ω
    kD /= Ωc # Sure?
    p = Dict(:kb=>kb, :kl=>kl, :kM=>kM, :h=>h, :kd=>kd, :kI=>kI, :λ=>λ, :kE=>kE, :kD=>kD )
    momentsMapping = MomentsMap(
                        :N=>1, :N2=>2,
                        :M¹=>3, :M¹2=>4,
                        :NM¹=>5,
                        )
    sigmaMapping = SigmaMap(
                        :N=>(:N2,:N),
                        :M¹=>(:M¹2,:M¹),
                        )
    ssaSys = getSimpleSwitchSSASystem(; kb=kb, kl=kl, kM=kM, h=h, kd=kd, kI=kI, λ=λ, kE=kE, kD=kD)
    # return Model(p, Ω, Ωc, SimpleSwitch_initial, SimpleSwitch_ODEs, ssaSys)
    # return Model(p, Ω, Ωc, SimpleSwitch_initial, SimpleSwitch_ODEs_2, ssaSys)
    return Model(p, Ω, Ωc, SimpleSwitch_initial, SimpleSwitch_ODEs_act, ssaSys, momentsMapping, sigmaMapping)
end

function getSimpleSwitchSSASystem(;
                            kb = 0., 
                            kl = 0.,
                            kM=0., h = 1., # Hill coeffs
                            kd = 0.,  # Parameter of the poisson distrib on intake
                            kE = 0., kD = 0., # Exit, Division
                            kI = 0., λ = 0.,
                            )
    S = Sim.System("SimpleSwitch", 1, # X1
            [:N =>[0], # Number of compartments
             :M¹ =>[1], # M¹
             :M² =>[2], # M²
            ]
            )

    # Activation function
    activation(xc::Compartments) = xc[1][1]^h / (kM^h + xc[1][1]^h)
    # cells' reaction network
    prodX1 = Sim.new_chemical_reaction_class([1], kb)
    prodX1.g = (xc::Compartments, Mom::Moments) -> kl + activation(xc)

    deathX1 = Sim.new_chemical_reaction_class([-1], kd)
    deathX1.g = (xc::Compartments, Mom::Moments) -> xc[1][1]
    deathX1.H = (n::SystemState, Mom::Moments) -> Mom[2]

    cellIntake = Sim.TransitionClass(0, 1, kI)
    cellIntake.H = (n::SystemState, Mom::Moments) -> 1
    # This is how the output compartment (yc) of the transition looks like
    cellIntake.pi = function(yc::Compartments, xc::Compartments)
                        yc[1][1] = rand(Poisson(λ))
                    end

    # cellExit = Sim.TransitionClass(1, 0, kE) # This is a cell death
    # cellExit.H = (n::SystemState, Mom::Moments) -> Mom[1] # Depends on num cells
    # cellExit.fast_sample_reactants! = fast_sample_uniform_cell
    cellExit = Sim.TransitionClass(2, 1, kE) # This is a cell death
    cellExit.H = (n::SystemState, Mom::Moments) -> Mom[1]*(Mom[1]-1)/2
    cellExit.fast_sample_reactants! = fast_sample_uniform_2cells
    cellExit.pi = function(yc::Compartments, xc::Compartments)
                            yc[1][:] .= xc[1][:]
                        end

    # coagulation = Sim.TransitionClass(2, 1, kC)
    # coagulation.H = (n::SystemState, Mom::Moments) -> Mom[1]*(Mom[1]-1)/2
    # coagulation.fast_sample_reactants! = fast_sample_uniform_2cells
    # coagulation.pi = function(yc::Compartments, xc::Compartments)
    #                         yc[1][:] .= xc[1][:] .+ xc[2][:]
    #                     end

    division = Sim.TransitionClass(1, 2, kD)
    # division.H = (n::SystemState, Mom::Moments) -> Mom[2]
    # division.fast_sample_reactants! = fast_sample_mass_x1
    division.g = (xc::Compartments, Mom::Moments) -> kl + activation(xc)
    division.pi = function(yc::Compartments, xc::Compartments)
                        yc[1][1] = rand(0:xc[1][1])
                        yc[2][1] = xc[1][1] - yc[1][1]
                    end
    # division.pi = function(yc::Compartments, xc::Compartments)
    #                 yc[1][1] = 1
    #                 yc[2][1] = 1
    #             end

    Sim.add_transition_class(S, 
                                prodX1, deathX1, 
                                cellIntake, 
                                cellExit, division,
                                )
    return S
end

function SimpleSwitch_ODEs(dM, M, parameters, t)
    c3 = parameters[:λ] # λ
    c4 = parameters[:h] # h
    c8 = parameters[:kM] # kM
    c2 = parameters[:kD] # kD
    c0 = parameters[:kE] # kE
    c7 = parameters[:kI] # kI
    c5 = parameters[:kb] # kb
    c6 = parameters[:kd] # kd
    c1 = parameters[:kl] # kl
    # Number of Compartments (N)
    dM[1] = c7+c2*M[3]-c0*M[1]
    # N^2
    dM[2] = c7+c2*M[3]+c0*M[1]-2*c0*M[2]+2*c2*M[5]+2*c7*M[1]
    # Total Mass
    dM[3] = (c3*c7*c8^c4+c3*c7*(M[3]/M[1])^c4+c5*(M[3]/M[1])^c4*M[1]-c0*c8^c4*M[3]-c0*(M[3]/M[1])^c4*M[3]-c6*c8^c4*M[3]-c6*(M[3]/M[1])^c4*M[3]+c1*c5*c8^c4*M[1]+c1*c5*(M[3]/M[1])^c4*M[1])/(c8^c4+(M[3]/M[1])^c4)
    # M^2
    dM[4] = (c0*c8^(2*c4)*M[3]^3+c0*(M[3]/M[1])^(2*c4)*M[3]^3+c5*(M[3]/M[1])^(2*c4)*M[1]^2*M[3]+c6*c8^(2*c4)*M[3]^2*M[1]+c6*(M[3]/M[1])^(2*c4)*M[3]^2*M[1]+2*c0*c8^c4*(M[3]/M[1])^c4*M[3]^3+c3*c7*c8^(2*c4)*M[1]*M[3]+c3*c7*(M[3]/M[1])^(2*c4)*M[1]*M[3]+c1*c5*c8^(2*c4)*M[1]^2*M[3]+c1*c5*(M[3]/M[1])^(2*c4)*M[1]^2*M[3]+c7*c3^2*c8^(2*c4)*M[1]*M[3]+c7*c3^2*(M[3]/M[1])^(2*c4)*M[1]*M[3]+c5*c8^c4*(M[3]/M[1])^c4*M[1]^2*M[3]-2*c0*c8^(2*c4)*M[4]*M[1]*M[3]-2*c0*(M[3]/M[1])^(2*c4)*M[4]*M[1]*M[3]-2*c6*c8^(2*c4)*M[4]*M[1]*M[3]-2*c6*(M[3]/M[1])^(2*c4)*M[4]*M[1]*M[3]+2*c3*c7*c8^(2*c4)*M[3]^2*M[1]+2*c3*c7*(M[3]/M[1])^(2*c4)*M[3]^2*M[1]+2*c5*(M[3]/M[1])^(2*c4)*M[5]*M[1]*M[3]+2*c6*c8^c4*(M[3]/M[1])^c4*M[3]^2*M[1]-4*c0*c8^c4*(M[3]/M[1])^c4*M[4]*M[1]*M[3]-4*c6*c8^c4*(M[3]/M[1])^c4*M[4]*M[1]*M[3]+2*c3*c7*c8^c4*(M[3]/M[1])^c4*M[1]*M[3]+2*c4*c5*c8^c4*(M[3]/M[1])^c4*M[1]^2*M[4]+2*c1*c5*c8^c4*(M[3]/M[1])^c4*M[1]^2*M[3]+2*c1*c5*c8^(2*c4)*M[5]*M[1]*M[3]+2*c1*c5*(M[3]/M[1])^(2*c4)*M[5]*M[1]*M[3]+2*c7*c3^2*c8^c4*(M[3]/M[1])^c4*M[1]*M[3]+2*c5*c8^c4*(M[3]/M[1])^c4*M[5]*M[1]*M[3]+4*c3*c7*c8^c4*(M[3]/M[1])^c4*M[3]^2*M[1]-2*c4*c5*c8^c4*(M[3]/M[1])^c4*M[5]*M[1]*M[3]+4*c1*c5*c8^c4*(M[3]/M[1])^c4*M[5]*M[1]*M[3])/((c8^(2*c4)+(M[3]/M[1])^(2*c4)+2*c8^c4*(M[3]/M[1])^c4)*M[1]*M[3])
    # N*M
    dM[5] = (c0*c8^(2*c4)*M[3]^2+c0*(M[3]/M[1])^(2*c4)*M[3]^2+c7*c8^(2*c4)*M[3]^2+c7*(M[3]/M[1])^(2*c4)*M[3]^2+c3*c7*c8^(2*c4)*M[3]+c3*c7*(M[3]/M[1])^(2*c4)*M[3]+c2*c8^(2*c4)*M[4]*M[3]+c2*(M[3]/M[1])^(2*c4)*M[4]*M[3]+c5*(M[3]/M[1])^(2*c4)*M[2]*M[3]-c6*c8^(2*c4)*M[5]*M[3]-c6*(M[3]/M[1])^(2*c4)*M[5]*M[3]-2*c0*c8^(2*c4)*M[5]*M[3]-2*c0*(M[3]/M[1])^(2*c4)*M[5]*M[3]+2*c0*c8^c4*(M[3]/M[1])^c4*M[3]^2+2*c7*c8^c4*(M[3]/M[1])^c4*M[3]^2+c3*c7*c8^(2*c4)*M[1]*M[3]+c3*c7*(M[3]/M[1])^(2*c4)*M[1]*M[3]+c1*c5*c8^(2*c4)*M[2]*M[3]+c1*c5*(M[3]/M[1])^(2*c4)*M[2]*M[3]+c5*c8^c4*(M[3]/M[1])^c4*M[2]*M[3]-4*c0*c8^c4*(M[3]/M[1])^c4*M[5]*M[3]-2*c6*c8^c4*(M[3]/M[1])^c4*M[5]*M[3]+2*c3*c7*c8^c4*(M[3]/M[1])^c4*M[3]+2*c2*c8^c4*(M[3]/M[1])^c4*M[4]*M[3]+c4*c5*c8^c4*(M[3]/M[1])^c4*M[5]*M[1]-c4*c5*c8^c4*(M[3]/M[1])^c4*M[2]*M[3]+2*c3*c7*c8^c4*(M[3]/M[1])^c4*M[1]*M[3]+2*c1*c5*c8^c4*(M[3]/M[1])^c4*M[2]*M[3])/((c8^(2*c4)+(M[3]/M[1])^(2*c4)+2*c8^c4*(M[3]/M[1])^c4)*M[3])
    return
end
function SimpleSwitch_ODEs_2(dM, M, parameters, t)
    c0 = parameters[:λ] # λ
    c3 = parameters[:h] # h
    c1 = parameters[:kM] # kM
    c5 = parameters[:kD] # kD
    c2 = parameters[:kE] # kE
    c6 = parameters[:kI] # kI
    c4 = parameters[:kb] # kb
    c8 = parameters[:kd] # kd
    c7 = parameters[:kl] # kl
    # Number of Compartments (N)
    dM[1] = c6+c5*M[3]+1/2*c2*M[1]-1/2*c2*M[1]^2
    # N^2
    dM[2] = c6+c5*M[3]+c2*M[1]^3+c2*M[2]+1/2*c2*M[1]^2+2*c5*M[5]+2*c6*M[1]-1/2*c2*M[1]-2*c2*M[2]*M[1]
    # Total Mass
    dM[3] = (c0*c6*c1^c3+c0*c6*(M[3]/M[1])^c3+c4*(M[3]/M[1])^c3*M[1]+1/2*c2*c1^c3*M[3]+1/2*c2*(M[3]/M[1])^c3*M[3]-c8*c1^c3*M[3]-c8*(M[3]/M[1])^c3*M[3]+c7*c4*c1^c3*M[1]+c7*c4*(M[3]/M[1])^c3*M[1]-1/2*c2*c1^c3*M[1]*M[3]-1/2*c2*(M[3]/M[1])^c3*M[1]*M[3])/(c1^c3+(M[3]/M[1])^c3)
    # M^2
    dM[4] = (-1/2*c2*c1^(2*c3)*M[3]^3-1/2*c2*(M[3]/M[1])^(2*c3)*M[3]^3+c2*c1^(2*c3)*M[1]^2*M[3]^3+c2*(M[3]/M[1])^(2*c3)*M[1]^2*M[3]^3+c4*(M[3]/M[1])^(2*c3)*M[1]^2*M[3]+c8*c1^(2*c3)*M[3]^2*M[1]+c8*(M[3]/M[1])^(2*c3)*M[3]^2*M[1]+1/2*c2*c1^(2*c3)*M[3]^3*M[1]+1/2*c2*(M[3]/M[1])^(2*c3)*M[3]^3*M[1]-c2*c1^c3*(M[3]/M[1])^c3*M[3]^3+c0*c6*c1^(2*c3)*M[1]*M[3]+c0*c6*(M[3]/M[1])^(2*c3)*M[1]*M[3]+c7*c4*c1^(2*c3)*M[1]^2*M[3]+c7*c4*(M[3]/M[1])^(2*c3)*M[1]^2*M[3]+c2*c1^c3*(M[3]/M[1])^c3*M[3]^3*M[1]+c2*c1^(2*c3)*M[4]*M[1]*M[3]+c2*(M[3]/M[1])^(2*c3)*M[4]*M[1]*M[3]+c6*c0^2*c1^(2*c3)*M[1]*M[3]+c6*c0^2*(M[3]/M[1])^(2*c3)*M[1]*M[3]+c4*c1^c3*(M[3]/M[1])^c3*M[1]^2*M[3]-c2*c1^(2*c3)*M[1]^2*M[4]*M[3]-c2*c1^(2*c3)*M[3]^2*M[5]*M[1]-c2*(M[3]/M[1])^(2*c3)*M[1]^2*M[4]*M[3]-c2*(M[3]/M[1])^(2*c3)*M[3]^2*M[5]*M[1]-2*c8*c1^(2*c3)*M[4]*M[1]*M[3]-2*c8*(M[3]/M[1])^(2*c3)*M[4]*M[1]*M[3]+2*c0*c6*c1^(2*c3)*M[3]^2*M[1]+2*c0*c6*(M[3]/M[1])^(2*c3)*M[3]^2*M[1]+2*c2*c1^c3*(M[3]/M[1])^c3*M[1]^2*M[3]^3+2*c4*(M[3]/M[1])^(2*c3)*M[5]*M[1]*M[3]+2*c8*c1^c3*(M[3]/M[1])^c3*M[3]^2*M[1]-4*c8*c1^c3*(M[3]/M[1])^c3*M[4]*M[1]*M[3]-2*c2*c1^c3*(M[3]/M[1])^c3*M[1]^2*M[4]*M[3]-2*c2*c1^c3*(M[3]/M[1])^c3*M[3]^2*M[5]*M[1]+2*c0*c6*c1^c3*(M[3]/M[1])^c3*M[1]*M[3]+2*c3*c4*c1^c3*(M[3]/M[1])^c3*M[1]^2*M[4]+2*c7*c4*c1^c3*(M[3]/M[1])^c3*M[1]^2*M[3]+2*c7*c4*c1^(2*c3)*M[5]*M[1]*M[3]+2*c7*c4*(M[3]/M[1])^(2*c3)*M[5]*M[1]*M[3]+2*c2*c1^c3*(M[3]/M[1])^c3*M[4]*M[1]*M[3]+2*c6*c0^2*c1^c3*(M[3]/M[1])^c3*M[1]*M[3]+2*c4*c1^c3*(M[3]/M[1])^c3*M[5]*M[1]*M[3]+4*c0*c6*c1^c3*(M[3]/M[1])^c3*M[3]^2*M[1]-2*c3*c4*c1^c3*(M[3]/M[1])^c3*M[5]*M[1]*M[3]+4*c7*c4*c1^c3*(M[3]/M[1])^c3*M[5]*M[1]*M[3])/((c1^(2*c3)+(M[3]/M[1])^(2*c3)+2*c1^c3*(M[3]/M[1])^c3)*M[1]*M[3])
    # N*M
    dM[5] = (c6*c1^(2*c3)*M[3]^2+c6*(M[3]/M[1])^(2*c3)*M[3]^2-1/2*c2*(c1^(2*c3)*M[3]+(M[3]/M[1])^(2*c3)*M[3]+c1^(2*c3)*M[2]*M[3]+(M[3]/M[1])^(2*c3)*M[2]*M[3]-c1^(2*c3)*M[1]*M[3]-(M[3]/M[1])^(2*c3)*M[1]*M[3]-2*c1^(2*c3)*M[1]^2*M[3]-2*(M[3]/M[1])^(2*c3)*M[1]^2*M[3]+3*c1^(2*c3)*M[5]*M[1]+3*(M[3]/M[1])^(2*c3)*M[5]*M[1])*M[3]+c0*c6*c1^(2*c3)*M[3]+c0*c6*(M[3]/M[1])^(2*c3)*M[3]+c5*c1^(2*c3)*M[4]*M[3]+c5*(M[3]/M[1])^(2*c3)*M[4]*M[3]+c2*c1^(2*c3)*M[5]*M[3]+c2*(M[3]/M[1])^(2*c3)*M[5]*M[3]+c4*(M[3]/M[1])^(2*c3)*M[2]*M[3]-c2*c1^c3*(M[3]/M[1])^c3*M[3]^2-c8*c1^(2*c3)*M[5]*M[3]-c8*(M[3]/M[1])^(2*c3)*M[5]*M[3]+2*c6*c1^c3*(M[3]/M[1])^c3*M[3]^2+c0*c6*c1^(2*c3)*M[1]*M[3]+c0*c6*(M[3]/M[1])^(2*c3)*M[1]*M[3]+c7*c4*c1^(2*c3)*M[2]*M[3]+c7*c4*(M[3]/M[1])^(2*c3)*M[2]*M[3]+c2*c1^c3*(M[3]/M[1])^c3*M[3]^2*M[1]+c4*c1^c3*(M[3]/M[1])^c3*M[2]*M[3]-c2*c1^c3*(M[3]/M[1])^c3*M[3]^2*M[2]-2*c8*c1^c3*(M[3]/M[1])^c3*M[5]*M[3]+2*c0*c6*c1^c3*(M[3]/M[1])^c3*M[3]+2*c5*c1^c3*(M[3]/M[1])^c3*M[4]*M[3]+2*c2*c1^c3*(M[3]/M[1])^c3*M[1]^2*M[3]^2+2*c2*c1^c3*(M[3]/M[1])^c3*M[5]*M[3]+c3*c4*c1^c3*(M[3]/M[1])^c3*M[5]*M[1]-c3*c4*c1^c3*(M[3]/M[1])^c3*M[2]*M[3]-3*c2*c1^c3*(M[3]/M[1])^c3*M[5]*M[1]*M[3]+2*c0*c6*c1^c3*(M[3]/M[1])^c3*M[1]*M[3]+2*c7*c4*c1^c3*(M[3]/M[1])^c3*M[2]*M[3])/((c1^(2*c3)+(M[3]/M[1])^(2*c3)+2*c1^c3*(M[3]/M[1])^c3)*M[3])
    return
end
function SimpleSwitch_ODEs_act(dM, M, parameters, t)
    c1 = parameters[:λ] # λ
    c5 = parameters[:h] # h
    c3 = parameters[:kM] # kM
    c6 = parameters[:kD] # kD
    c4 = parameters[:kE] # kE
    c7 = parameters[:kI] # kI
    c8 = parameters[:kb] # kb
    c2 = parameters[:kd] # kd
    c0 = parameters[:kl] # kl
    # Number of Compartments (N)
    dM[1] = (c7*c3^c5+c7*(M[3]/M[1])^c5+c6*(M[3]/M[1])^c5*M[1]+1/2*c4*c3^c5*M[1]+1/2*c4*(M[3]/M[1])^c5*M[1]-1/2*c4*c3^c5*M[1]^2-1/2*c4*(M[3]/M[1])^c5*M[1]^2+c0*c6*c3^c5*M[1]+c0*c6*(M[3]/M[1])^c5*M[1])/(c3^c5+(M[3]/M[1])^c5)
    # N^2
    dM[2] = (c7*c3^(2*c5)*M[3]+c7*(M[3]/M[1])^(2*c5)*M[3]+c6*(M[3]/M[1])^(2*c5)*M[1]*M[3]+c4*c3^(2*c5)*M[1]^3*M[3]+c4*c3^(2*c5)*M[2]*M[3]+c4*(M[3]/M[1])^(2*c5)*M[1]^3*M[3]+c4*(M[3]/M[1])^(2*c5)*M[2]*M[3]+1/2*c4*c3^(2*c5)*M[1]^2*M[3]+1/2*c4*(M[3]/M[1])^(2*c5)*M[1]^2*M[3]+2*c6*(M[3]/M[1])^(2*c5)*M[2]*M[3]+2*c7*c3^c5*(M[3]/M[1])^c5*M[3]+2*c7*c3^(2*c5)*M[1]*M[3]+2*c7*(M[3]/M[1])^(2*c5)*M[1]*M[3]-1/2*c4*c3^(2*c5)*M[1]*M[3]-1/2*c4*(M[3]/M[1])^(2*c5)*M[1]*M[3]+c0*c6*c3^(2*c5)*M[1]*M[3]+c0*c6*(M[3]/M[1])^(2*c5)*M[1]*M[3]+c6*c3^c5*(M[3]/M[1])^c5*M[1]*M[3]+c4*c3^c5*(M[3]/M[1])^c5*M[1]^2*M[3]-c4*c3^c5*(M[3]/M[1])^c5*M[1]*M[3]-2*c4*c3^(2*c5)*M[2]*M[1]*M[3]-2*c4*(M[3]/M[1])^(2*c5)*M[2]*M[1]*M[3]+2*c0*c6*c3^(2*c5)*M[2]*M[3]+2*c0*c6*(M[3]/M[1])^(2*c5)*M[2]*M[3]+2*c6*c3^c5*(M[3]/M[1])^c5*M[2]*M[3]+2*c4*c3^c5*(M[3]/M[1])^c5*M[1]^3*M[3]+2*c4*c3^c5*(M[3]/M[1])^c5*M[2]*M[3]+4*c7*c3^c5*(M[3]/M[1])^c5*M[1]*M[3]-4*c4*c3^c5*(M[3]/M[1])^c5*M[2]*M[1]*M[3]-2*c5*c6*c3^c5*(M[3]/M[1])^c5*M[2]*M[3]+2*c5*c6*c3^c5*(M[3]/M[1])^c5*M[5]*M[1]+2*c0*c6*c3^c5*(M[3]/M[1])^c5*M[1]*M[3]+4*c0*c6*c3^c5*(M[3]/M[1])^c5*M[2]*M[3])/((c3^(2*c5)+(M[3]/M[1])^(2*c5)+2*c3^c5*(M[3]/M[1])^c5)*M[3])
    # Total Mass
    dM[3] = (c1*c7*c3^c5+c1*c7*(M[3]/M[1])^c5+c8*(M[3]/M[1])^c5*M[1]+1/2*c4*c3^c5*M[3]+1/2*c4*(M[3]/M[1])^c5*M[3]-c2*c3^c5*M[3]-c2*(M[3]/M[1])^c5*M[3]+c0*c8*c3^c5*M[1]+c0*c8*(M[3]/M[1])^c5*M[1]-1/2*c4*c3^c5*M[1]*M[3]-1/2*c4*(M[3]/M[1])^c5*M[1]*M[3])/(c3^c5+(M[3]/M[1])^c5)
    # M^2
    dM[4] = (-1/2*c4*c3^(2*c5)*M[3]^3-1/2*c4*(M[3]/M[1])^(2*c5)*M[3]^3+c4*c3^(2*c5)*M[1]^2*M[3]^3+c4*(M[3]/M[1])^(2*c5)*M[1]^2*M[3]^3+c8*(M[3]/M[1])^(2*c5)*M[1]^2*M[3]+c2*c3^(2*c5)*M[3]^2*M[1]+c2*(M[3]/M[1])^(2*c5)*M[3]^2*M[1]+1/2*c4*c3^(2*c5)*M[3]^3*M[1]+1/2*c4*(M[3]/M[1])^(2*c5)*M[3]^3*M[1]-c4*c3^c5*(M[3]/M[1])^c5*M[3]^3+c1*c7*c3^(2*c5)*M[1]*M[3]+c1*c7*(M[3]/M[1])^(2*c5)*M[1]*M[3]+c0*c8*c3^(2*c5)*M[1]^2*M[3]+c0*c8*(M[3]/M[1])^(2*c5)*M[1]^2*M[3]+c4*c3^c5*(M[3]/M[1])^c5*M[3]^3*M[1]+c4*c3^(2*c5)*M[4]*M[1]*M[3]+c4*(M[3]/M[1])^(2*c5)*M[4]*M[1]*M[3]+c7*c1^2*c3^(2*c5)*M[1]*M[3]+c7*c1^2*(M[3]/M[1])^(2*c5)*M[1]*M[3]+c8*c3^c5*(M[3]/M[1])^c5*M[1]^2*M[3]-c4*c3^(2*c5)*M[1]^2*M[4]*M[3]-c4*c3^(2*c5)*M[3]^2*M[5]*M[1]-c4*(M[3]/M[1])^(2*c5)*M[1]^2*M[4]*M[3]-c4*(M[3]/M[1])^(2*c5)*M[3]^2*M[5]*M[1]-2*c2*c3^(2*c5)*M[4]*M[1]*M[3]-2*c2*(M[3]/M[1])^(2*c5)*M[4]*M[1]*M[3]+2*c1*c7*c3^(2*c5)*M[3]^2*M[1]+2*c1*c7*(M[3]/M[1])^(2*c5)*M[3]^2*M[1]+2*c4*c3^c5*(M[3]/M[1])^c5*M[1]^2*M[3]^3+2*c8*(M[3]/M[1])^(2*c5)*M[5]*M[1]*M[3]+2*c2*c3^c5*(M[3]/M[1])^c5*M[3]^2*M[1]-4*c2*c3^c5*(M[3]/M[1])^c5*M[4]*M[1]*M[3]-2*c4*c3^c5*(M[3]/M[1])^c5*M[1]^2*M[4]*M[3]-2*c4*c3^c5*(M[3]/M[1])^c5*M[3]^2*M[5]*M[1]+2*c1*c7*c3^c5*(M[3]/M[1])^c5*M[1]*M[3]+2*c5*c8*c3^c5*(M[3]/M[1])^c5*M[1]^2*M[4]+2*c0*c8*c3^c5*(M[3]/M[1])^c5*M[1]^2*M[3]+2*c0*c8*c3^(2*c5)*M[5]*M[1]*M[3]+2*c0*c8*(M[3]/M[1])^(2*c5)*M[5]*M[1]*M[3]+2*c4*c3^c5*(M[3]/M[1])^c5*M[4]*M[1]*M[3]+2*c7*c1^2*c3^c5*(M[3]/M[1])^c5*M[1]*M[3]+2*c8*c3^c5*(M[3]/M[1])^c5*M[5]*M[1]*M[3]+4*c1*c7*c3^c5*(M[3]/M[1])^c5*M[3]^2*M[1]-2*c5*c8*c3^c5*(M[3]/M[1])^c5*M[5]*M[1]*M[3]+4*c0*c8*c3^c5*(M[3]/M[1])^c5*M[5]*M[1]*M[3])/((c3^(2*c5)+(M[3]/M[1])^(2*c5)+2*c3^c5*(M[3]/M[1])^c5)*M[1]*M[3])
    # N*M
    dM[5] = (c7*c3^(2*c5)*M[3]^2+c7*(M[3]/M[1])^(2*c5)*M[3]^2-1/2*c4*(c3^(2*c5)*M[3]+(M[3]/M[1])^(2*c5)*M[3]+c3^(2*c5)*M[2]*M[3]+(M[3]/M[1])^(2*c5)*M[2]*M[3]-c3^(2*c5)*M[1]*M[3]-(M[3]/M[1])^(2*c5)*M[1]*M[3]-2*c3^(2*c5)*M[1]^2*M[3]-2*(M[3]/M[1])^(2*c5)*M[1]^2*M[3]+3*c3^(2*c5)*M[5]*M[1]+3*(M[3]/M[1])^(2*c5)*M[5]*M[1])*M[3]+c1*c7*c3^(2*c5)*M[3]+c1*c7*(M[3]/M[1])^(2*c5)*M[3]+c6*(M[3]/M[1])^(2*c5)*M[5]*M[3]+c4*c3^(2*c5)*M[5]*M[3]+c4*(M[3]/M[1])^(2*c5)*M[5]*M[3]+c8*(M[3]/M[1])^(2*c5)*M[2]*M[3]-c4*c3^c5*(M[3]/M[1])^c5*M[3]^2-c2*c3^(2*c5)*M[5]*M[3]-c2*(M[3]/M[1])^(2*c5)*M[5]*M[3]+2*c7*c3^c5*(M[3]/M[1])^c5*M[3]^2+c1*c7*c3^(2*c5)*M[1]*M[3]+c1*c7*(M[3]/M[1])^(2*c5)*M[1]*M[3]+c0*c6*c3^(2*c5)*M[5]*M[3]+c0*c6*(M[3]/M[1])^(2*c5)*M[5]*M[3]+c0*c8*c3^(2*c5)*M[2]*M[3]+c0*c8*(M[3]/M[1])^(2*c5)*M[2]*M[3]+c6*c3^c5*(M[3]/M[1])^c5*M[5]*M[3]+c4*c3^c5*(M[3]/M[1])^c5*M[3]^2*M[1]+c8*c3^c5*(M[3]/M[1])^c5*M[2]*M[3]-c4*c3^c5*(M[3]/M[1])^c5*M[3]^2*M[2]-2*c2*c3^c5*(M[3]/M[1])^c5*M[5]*M[3]+2*c1*c7*c3^c5*(M[3]/M[1])^c5*M[3]+2*c4*c3^c5*(M[3]/M[1])^c5*M[1]^2*M[3]^2+2*c4*c3^c5*(M[3]/M[1])^c5*M[5]*M[3]+c5*c6*c3^c5*(M[3]/M[1])^c5*M[4]*M[1]+c5*c8*c3^c5*(M[3]/M[1])^c5*M[5]*M[1]-c5*c6*c3^c5*(M[3]/M[1])^c5*M[5]*M[3]-c5*c8*c3^c5*(M[3]/M[1])^c5*M[2]*M[3]-3*c4*c3^c5*(M[3]/M[1])^c5*M[5]*M[1]*M[3]+2*c1*c7*c3^c5*(M[3]/M[1])^c5*M[1]*M[3]+2*c0*c6*c3^c5*(M[3]/M[1])^c5*M[5]*M[3]+2*c0*c8*c3^c5*(M[3]/M[1])^c5*M[2]*M[3])/((c3^(2*c5)+(M[3]/M[1])^(2*c5)+2*c3^c5*(M[3]/M[1])^c5)*M[3])
    return
end

# initialize expected moments vector
function SimpleSwitch_initial(N0, Mpc0)
    M0 = N0*Mpc0
    M = zeros(5)
    # Number of Compartments (N)
    M[1] = N0 # initial value for Moment(0,), please specify!
    # N^2
    M[2] = M[1]^2
    # Total Mass
    M[3] = M0 # initial value for Moment(1,), please specify!
    # M^2
    M[4] = M[3]^2
    # N*M
    M[5] = M[1]*M[3]
    return M
end

##################### StemCells

@export function StemCells(; kP = 1e-2, kD = 1e-2,
                             kE = 5e-2, ka = 10.0, 
                             kNF = 1e-2,
                             Ω=1.0, Ωc=1.0,
                            )
    kP, kD, kE, ka, kNF, Ω, Ωc = float.( (kP, kD, kE, ka, kNF, Ω, Ωc) )
    kNF /= Ω
    kP /= Ωc
    kD /= Ωc
    p = Dict(:kP=>kP, :kD=>kD, :kE=>kE, :ka=>ka, :kNF=>kNF, 
                :Ω=>Ω, :Ωc=>Ωc,
                )
    ssaSys = getStemCellsSSASystem(; kP=kP, kD=kD, kE=kE, ka=ka, kNF=kNF)
    labelsOde = [:N, :N2, :M¹⁰, :M¹⁰2, :NM¹⁰, :M⁰¹, :NM⁰¹, :M¹⁰M⁰¹, :M⁰¹2]
    return Model(p, Ω, Ωc, StemCells_initial_lin, StemCells_ODEs_lin, ssaSys)
end

function getStemCellsSSASystem(;
                            kP = 0.0, kD = 0.0,
                            kE = 0.0, ka = 0.0, 
                            kNF = 0.0,
                            )
    S = Sim.System("StemCells", 2, # X1, X2
            [:N =>[0,0], # Number of cells
             :M¹⁰ =>[1,0], # M¹⁰ Stem Cells
             :M⁰¹ =>[0,1], # M⁰¹ All cells age
             :M¹¹ =>[1,1], # M¹¹ Stem cells age
            ]
            )

    proliferation = Sim.TransitionClass(1, 2, kP)
    proliferation.H = (n::SystemState, Mom::Moments) -> Mom[4]
    proliferation.g = (xc::Compartments, Mom::Moments) -> (xc[1][1]==1)*xc[1][2]
    proliferation.pi = function(yc::Compartments, xc::Compartments)
                            yc[1][:] .= 1, 0
                            yc[2][:] .= 1, 0
                        end

    differentiation = Sim.TransitionClass(1, 2, kD)
    differentiation.H = (n::SystemState, Mom::Moments) -> Mom[4]
    differentiation.g = (xc::Compartments, Mom::Moments) -> (xc[1][1]==1)*xc[1][2]
    differentiation.pi = function(yc::Compartments, xc::Compartments)
                            yc[1][:] .= 1, 0
                            yc[2][:] .= 0, 0
                        end

    exit = Sim.TransitionClass(1, 0, kE) # This is a cell death
    exit.H = (n::SystemState, Mom::Moments) -> Mom[1]-Mom[2] # Depends on non-stem cells
    exit.g = (xc::Compartments, Mom::Moments) -> 1.0*(xc[1][1]==0)

    ageing = Sim.new_chemical_reaction_class([0,1], ka)
    ageing.H = (n::SystemState, Mom::Moments) -> Mom[2] # Only stem cells do age!
    ageing.g = (xc::Compartments, Mom::Moments) -> 1.0*(xc[1][1]==1)

    negFeedback = Sim.TransitionClass(2, 2, kNF)
    negFeedback.H = (n::SystemState, Mom::Moments) -> div(Mom[2]*(Mom[2]-1), 2)
    negFeedback.g = (xc::Compartments, Mom::Moments) -> 1.0*(xc[1][1]==1)*(xc[2][1]==1)
    negFeedback.pi = function(yc::Compartments, xc::Compartments)
                        yc[1][:] .= 1, xc[1][1]
                        yc[2][:] .= 0, 0
                    end

    Sim.add_transition_class(S, 
        proliferation, differentiation, exit, ageing, negFeedback)

    return S
end

function StemCells_ODEs_lin(dM, M, parameters, t)
    c1 = parameters[:kD] # kD
    c0 = parameters[:kE] # kE
    c2 = parameters[:kNF] # kNF
    c4 = parameters[:kP] # kP
    c3 = parameters[:ka] # ka
    # Number of Compartments (N)
    dM[1] = (c1*M[8]*M[3]+c4*M[8]*M[3]-c0*(-M[3]+M[1])*M[1])/M[1]
    # N^2
    dM[2] = (c1*M[8]*M[3]+c4*M[8]*M[3]-c0*(-M[1]+2*M[2]+M[3])*M[1]+2*c1*M[5]*M[3]+2*c0*M[2]*M[3]+2*c4*M[5]*M[3])/M[1]
    # Total Mass of species 1
    dM[3] = 1/2*(c2*M[3]+2*c4*M[8]-c2*M[1]*M[3])*M[3]/M[1]
    # M1^2
    dM[4] = 1/2*(-(c2*M[3]-4*c4*M[6]-2*c4*M[8]+4*c2*M[7]*M[3])*M[1]+2*c2*M[7]*M[3]+c2*M[1]^2*(1+2*M[3])*M[3])*M[3]/M[1]^2
    # N*M2
    dM[5] = 1/2*(M[1]^3*(-4*c0*M[5]+2*c0*M[8]+c2*M[3]^2*M[8])+M[1]^2*(-2*c0*M[8]+2*c1*M[9]+2*c4*M[9]+2*c3*M[2]+4*c0*M[5]-c2*M[5]*M[3])*M[3]-(2*c1*M[8]^2+2*c4*M[8]^2-c2*M[5]*M[3]+4*c1*M[5]*M[8]+4*c4*M[5]*M[8]+c2*M[2]*M[8]*M[3])*M[1]*M[3]+2*M[8]^2*(c1+c4)*M[2]*M[3])/M[1]^3
    # M2*M1
    dM[6] = 1/2*(M[1]^3*(-2*c0*M[6]+c2*M[3]^2*M[8])+M[1]^2*(2*c0*M[6]+2*c4*M[9]+2*c3*M[7]+c2*M[3]^2*M[8]+c2*M[8]*M[3]-c2*M[6]*M[3]-2*c2*M[5]*M[3])*M[3]-(2*c4*M[8]^2+c2*M[8]*M[3]-c2*M[5]*M[3]-c2*M[6]*M[3]+4*c1*M[6]*M[8]+4*c4*M[6]*M[8]+c2*M[7]*M[8]*M[3])*M[1]*M[3]+2*M[8]^2*(c1+c4)*M[7]*M[3])/M[1]^3
    # N*M1
    dM[7] = 1/2*(M[1]^2*(-2*c0*M[7]+c2*M[3]^2*M[1])+c2*M[3]^2*M[2]+2*(c1*M[6]+c0*M[7]+c4*M[5]+c4*M[6]+c4*M[8]-c2*M[2]*M[3])*M[1]*M[3])/M[1]^2
    # Total Mass of species 2
    dM[8] = 1/2*(2*M[1]^2*(c3*M[3]-c0*M[8])-(-c2*M[3]+2*c1*M[8]+2*c4*M[8])*M[8]*M[3]+(2*c0-c2*M[3])*M[1]*M[8]*M[3])/M[1]^2
    # M2^2
    dM[9] = 1/2*(2*M[1]^2*(c0*M[8]^2+c2*M[8]^2*M[3]^2-c2*M[3]^2*M[9]+2*c0*M[9]*M[3]+2*c3*M[5]*M[3])+2*M[1]^3*(c3*M[3]-2*c0*M[9])+M[8]^2*(-c2*M[3]+2*c1*M[8]+2*c4*M[8]+4*c1*M[5]+4*c4*M[5])*M[3]-(2*c0*M[8]^2-c2*M[8]^2*M[3]-2*c2*M[9]*M[3]+8*c1*M[9]*M[8]+8*c4*M[9]*M[8]+2*c2*M[5]*M[8]*M[3])*M[1]*M[3])/M[1]^3
    return
end

# initialize expected moments vector
function StemCells_initial_lin(N0, Mpc0=0)
    # @assert Mpc0==1 "In this model Mpc0 only makes sense if == 1!"
    M = zeros(9)
    # Number of Compartments (N)
    M[1] = N0 # initial value for Moment(0, 0), please specify!
    # N^2
    M[2] = M[1]^2
    # Total Mass of species 1
    M[3] = N0 # initial value for Moment(1, 0), please specify!
    # M1^2
    M[4] = M[3]^2
    # N*M1
    M[7] = M[1]*M[3]
    # Total Mass of species 2
    M[8] = N0*Mpc0 # initial value for Moment(0, 1), please specify!
    # N*M2
    M[5] = M[1]*M[8]
    # M2*M1
    M[6] = M[8]*M[3]
    # M2^2
    M[9] = M[8]^2
    return M
end

function StemCells_ODEs_lin2(dM, M, parameters, t)
    c0 = parameters[:kD] # kD
    c4 = parameters[:kE] # kE
    c1 = parameters[:kNF] # kNF
    c2 = parameters[:kP] # kP
    c3 = parameters[:ka] # ka
    # Number of Compartments (N)
    dM[1] = (c0*M[6]*M[3]+c2*M[6]*M[3]-c4*(-M[3]+M[1])*M[1])/M[1]
    # N^2
    dM[2] = (c0*M[6]*M[3]+c2*M[6]*M[3]-c4*(-M[1]+2*M[2]+M[3])*M[1]+2*c0*M[7]*M[3]+2*c4*M[2]*M[3]+2*c2*M[7]*M[3])/M[1]
    # Total Mass of species 1
    dM[3] = 1/2*(c1*M[3]+2*c2*M[6]-c1*M[1]*M[3])*M[3]/M[1]
    # M1^2
    dM[4] = 1/2*(-(c1*M[3]-4*c2*M[8]-2*c2*M[6]+4*c1*M[5]*M[3])*M[1]+2*c1*M[5]*M[3]+c1*M[1]^2*(1+2*M[3])*M[3])*M[3]/M[1]^2
    # N*M1
    dM[5] = 1/2*(M[1]^2*(-2*c4*M[5]+c1*M[3]^2*M[1])+c1*M[3]^2*M[2]+2*(c0*M[8]+c4*M[5]+c2*M[7]+c2*M[8]+c2*M[6]-c1*M[2]*M[3])*M[1]*M[3])/M[1]^2
    # Total Mass of species 2
    dM[6] = 1/2*(2*M[1]^2*(c3*M[3]-c4*M[6])-(-c1*M[3]+2*c0*M[6]+2*c2*M[6])*M[6]*M[3]+(2*c4-c1*M[3])*M[1]*M[6]*M[3])/M[1]^2
    # N*M2
    dM[7] = 1/2*(M[1]^3*(-4*c4*M[7]+2*c4*M[6]+c1*M[3]^2*M[6])+M[1]^2*(-2*c4*M[6]+2*c0*M[9]+2*c2*M[9]+2*c3*M[2]+4*c4*M[7]-c1*M[7]*M[3])*M[3]-(2*c0*M[6]^2+2*c2*M[6]^2-c1*M[7]*M[3]+4*c0*M[7]*M[6]+4*c2*M[7]*M[6]+c1*M[2]*M[6]*M[3])*M[1]*M[3]+2*M[6]^2*(c0+c2)*M[2]*M[3])/M[1]^3
    # M2*M1
    dM[8] = 1/2*(M[1]^3*(-2*c4*M[8]+c1*M[3]^2*M[6])+M[1]^2*(2*c4*M[8]+2*c2*M[9]+2*c3*M[5]+c1*M[3]^2*M[6]+c1*M[6]*M[3]-c1*M[8]*M[3]-2*c1*M[7]*M[3])*M[3]-(2*c2*M[6]^2+c1*M[6]*M[3]-c1*M[7]*M[3]-c1*M[8]*M[3]+4*c0*M[8]*M[6]+4*c2*M[8]*M[6]+c1*M[5]*M[6]*M[3])*M[1]*M[3]+2*M[6]^2*(c0+c2)*M[5]*M[3])/M[1]^3
    # M2^2
    dM[9] = 1/2*(2*M[1]^2*(c4*M[6]^2+c1*M[6]^2*M[3]^2-c1*M[3]^2*M[9]+2*c4*M[9]*M[3]+2*c3*M[7]*M[3])+2*M[1]^3*(c3*M[3]-2*c4*M[9])+M[6]^2*(-c1*M[3]+2*c0*M[6]+2*c2*M[6]+4*c0*M[7]+4*c2*M[7])*M[3]-(2*c4*M[6]^2-c1*M[6]^2*M[3]-2*c1*M[9]*M[3]+8*c0*M[9]*M[6]+8*c2*M[9]*M[6]+2*c1*M[7]*M[6]*M[3])*M[1]*M[3])/M[1]^3
    return
end

# initialize expected moments vector
function StemCells_initial_lin2(N0, Mpc0=0)
    # @assert Mpc0==1 "In this model Mpc0 only makes sense if == 1!"
    M = zeros(9)
    # Number of Compartments (N)
    M[1] = N0 # initial value for Moment(0, 0), please specify!
    # N^2
    M[2] = M[1]^2
    # Total Mass of species 1
    M[3] = N0 # initial value for Moment(1, 0), please specify!
    # M1^2
    M[4] = M[3]^2
    # N*M1
    M[5] = M[1]*M[3]
    # Total Mass of species 2
    M[6] = N0*Mpc0 # initial value for Moment(0, 1), please specify!
    # N*M2
    M[7] = M[1]*M[6]
    # M2*M1
    M[8] = M[6]*M[3]
    # M2^2
    M[9] = M[6]^2
    return M
end

function StemCells_ODEs(dM, M, parameters, t)
    c2 = parameters[:kD] # kD
    c1 = parameters[:kE] # kE
    c4 = parameters[:kNF] # kNF
    c3 = parameters[:kP] # kP
    c0 = parameters[:ka] # ka
    # Number of Compartments (N)
    dM[1] = c2*M[5]+c1*M[3]+c3*M[5]-c1*M[1]
    # N^2
    dM[2] = c2*M[5]+c1*M[1]+c3*M[5]-c1*M[3]-2*c1*M[2]+2*c2*M[6]+2*c1*M[7]+2*c3*M[6]
    # Total Mass of species 1
    dM[3] = c3*M[5]+1/2*c4*M[3]-1/2*c4*M[3]^2
    # M1^2
    dM[4] = c4*M[3]^3+c4*M[4]+c3*M[5]+1/2*c4*M[3]^2-1/2*c4*M[3]-2*c4*M[4]*M[3]+2*c3*M[3]*M[5]
    # Sum of squared content of species 1
    dM[5] = (1/2*M[1]^2*(c4*M[5]+2*c0*M[3]-c4*M[3]*M[5])+M[5]^2*(c2+c3)*M[3]-2*M[5]^2*(c2+c3)*M[1])/M[1]^2
    # N*S1
    dM[6] = 1/2*(M[1]^2*(c4*M[6]-2*c1*M[6]+2*c2*M[8]+2*c3*M[8]+2*c0*M[7]-c4*M[7]*M[5]-c4*M[6]*M[3]+2*c1*M[3]*M[5]+c4*M[1]*M[3]*M[5])+2*M[5]^2*(c2*M[7]+c2*M[3]+c3*M[7]+c3*M[3])-4*(c2*M[6]+c2*M[5]+c3*M[6]+c3*M[5])*M[1]*M[5])/M[1]^2
    # N*M1
    dM[7] = c1*M[4]+c3*M[6]+c3*M[5]+1/2*c4*M[7]-c1*M[7]+c2*M[3]*M[5]+c3*M[3]*M[5]+1/2*c4*M[3]^2*M[1]-c4*M[7]*M[3]
    # S1^2
    dM[8] = 1/2*(2*M[1]^3*(c4*M[8]+c0*M[3]-c4*M[8]*M[3]+2*c0*M[3]*M[5])+M[5]^2*(c4*M[3]-c4*M[3]^2+6*c2*M[5]+6*c3*M[5]+4*c2*M[3]*M[5]+4*c3*M[3]*M[5])*M[1]-4*M[5]^3*(c2+c3)*M[3]-2*M[1]^2*(c4*M[5]+4*c2*M[8]+4*c3*M[8]-c4*M[3]*M[5])*M[5])/M[1]^3
    return
end

# initialize expected moments vector
function StemCells_initial(N0, Mpc0=0)
    # @assert Mpc0==1 "In this model Mpc0 only makes sense if == 1!"
    M = zeros(8)
    # Number of Compartments (N)
    M[1] = N0 # initial value for Moment(0, 0), please specify!
    # N^2
    M[2] = M[1]^2
    # Total Mass of species 1
    M[3] = N0 # initial value for Moment(1, 0), please specify!
    # M1^2
    M[4] = M[3]^2
    # Sum of squared content of species 1
    M[5] = N0*Mpc0 # initial value for Moment(1, 1), please specify!
    # N*S1
    M[6] = M[1]*M[5]
    # N*M1
    M[7] = M[1]*M[3]
    # S1^2
    M[8] = M[5]^2
    return M
end

##################### IntakeExitCoagulation(Hill)FragmentationBirthDeath

@export function IEChFBD(; 
                            kI=5.0, kE=0.1, 
                            kC=5e-3, kF=5e-3, 
                            kb=10.0, kd=0.1, 
                            λ=10.0, 
                            kM = 10, h = 1,
                            Ω=1.0, Ωc=1.0,
                            )
    kI, kE, kC, kF, kb, kd, λ, kM, Ω, Ωc = float.( (kI, kE, kC, kF, kb, kd, λ, kM, Ω, Ωc) )
    kI *= Ω; kC /= Ω*Ωc^2
    kb *= Ωc; kF /= Ωc
    kM *= Ωc # Right?
    p = Dict(:kI=>kI, :kE=>kE, :kC=>kC, :kF=>kF, :kb=>kb, :kd=>kd, :λ=>λ, 
                :kM=>kM, :h=>h,
                :Ω=>Ω, :Ωc=>Ωc,
                )
    ssaSys = getIEChFBDSSASystem(; kI=kI, kE=kE, kC=kC, kF=kF, kb=kb, kd=kd, λ=λ, kM=kM, h=h)
    return Model(p, Ω, Ωc, IECpFBD_initial, IEChFBD_ODEs, ssaSys)
end

function getIEChFBDSSASystem(;
                            kI = 0.0, kE = 0.0,  # Intake/Exit rates for cells
                            kC = 0.0, kF = 0.0,  # Coag/Frag rates for cells
                            kb = 0.0, kd = 0.0,  # Birth/Death rates for X1
                            λ = 0,  # Parameter of the poisson distrib on intake
                            kM = 0, # Michaelis-Menten constant
                            h = 1, # The Hill exponent
                            )
    S = Sim.System("IEChFBD", 1, # X1
            [:N =>[0], # Number of compartments
             :M¹ =>[1], # M¹
             :M² =>[2], # M²
            ]
            )

    # cells' reaction network
    prodX1 = Sim.new_chemical_reaction_class([1], kb)
    prodX1.H = (n::SystemState, Mom::Moments) -> Mom[1]
    prodX1.fast_sample_reactants! = fast_sample_uniform_cell

    deathX1 = Sim.new_chemical_reaction_class([-1], kd)
    deathX1.H = (n::SystemState, Mom::Moments) -> Mom[2]
    # deathX1.g = (xc::Compartments, Mom::Moments) -> xc[1][1]
    deathX1.fast_sample_reactants! = fast_sample_mass_x1

    # Compartment reactions
    cellIntake = Sim.TransitionClass(0, 1, kI)
    cellIntake.H = (n::SystemState, Mom::Moments) -> 1
    # This is how the output compartment (yc) of the transition looks like
    cellIntake.pi = function(yc::Compartments, xc::Compartments)
                        yc[1][1] = rand(Poisson(λ))
                    end

    cellExit = Sim.TransitionClass(1, 0, kE) # This is a cell death
    cellExit.H = (n::SystemState, Mom::Moments) -> Mom[1] # Depends on num cells
    cellExit.fast_sample_reactants! = fast_sample_uniform_cell

    coagulation = Sim.TransitionClass(2, 1, kC)
    coagulation.g = (xc::Compartments, Mom::Moments) -> ( xc[1][1]+xc[2][1])^h / ( (xc[1][1]+xc[2][1])^h + kM^h )
    coagulation.pi = function(yc::Compartments, xc::Compartments)
                            yc[1][:] .= xc[1][:] .+ xc[2][:]
                        end

    fragmentation = Sim.TransitionClass(1, 2, kF)
    fragmentation.H = (n::SystemState, Mom::Moments) -> Mom[2]
    fragmentation.fast_sample_reactants! = fast_sample_mass_x1
    fragmentation.pi = function(yc::Compartments, xc::Compartments)
                        yc[1][1] = rand(0:xc[1][1])
                        yc[2][1] = xc[1][1] - yc[1][1]
                    end

    Sim.add_transition_class(S, prodX1, deathX1, 
        cellIntake, cellExit, coagulation, fragmentation)

    return S
end

function IEChFBD_ODEs(dM, M, parameters, t)
    c4 = parameters[:λ] # λ
    c0 = parameters[:h] # h
    c2 = parameters[:kM] # kM
    c8 = parameters[:kC] # kC
    c3 = parameters[:kE] # kE
    c7 = parameters[:kF] # kF
    c5 = parameters[:kI] # kI
    c1 = parameters[:kb] # kb
    c6 = parameters[:kd] # kd
    # Number of Compartments (N)
    dM[1] = ((c2^c0+(2*M[3]/M[1])^c0)*(c5+c7*M[3]-c3*M[1])*(c2^(2*c0)+4^c0*(M[3]/M[1])^(2*c0)+2^(1+c0)*c2^c0*(M[3]/M[1])^c0)-1/2*c8*(2*M[3]/M[1])^c0*M[1]^2*(c2^(2*c0)+4^c0*(M[3]/M[1])^(2*c0)+2^(1+c0)*c2^c0*(M[3]/M[1])^c0)+1/2*c8*(M[3]/M[1])^c0*(c2^c0+(2*M[3]/M[1])^c0)*((2*c2)^c0+(4*M[3]/M[1])^c0)*M[1])/((c2^c0+2^c0*(M[3]/M[1])^c0)*(c2^(2*c0)+2^(2*c0)*(M[3]/M[1])^(2*c0)+2*2^c0*c2^c0*(M[3]/M[1])^c0))
    # N^2
    dM[2] = (c2^c0+(2*M[3]/M[1])^c0)*(c2^(2*c0)+4^c0*(M[3]/M[1])^(2*c0)+2*2^c0*c2^c0*(M[3]/M[1])^c0)*(c8*(M[3]/M[1])^c0*(c2^c0+(2*M[3]/M[1])^c0)*((2*c2)^c0*M[2]*M[3]+(4*M[3]/M[1])^c0*M[2]*M[3]+c0*(2*c2)^c0*M[5]*M[1]-c0*(2*c2)^c0*M[2]*M[3])+(c2^c0+(2*M[3]/M[1])^c0)*(c2^(2*c0)+4^c0*(M[3]/M[1])^(2*c0)+2*2^c0*c2^c0*(M[3]/M[1])^c0)*(c5+c3*M[1]+c7*M[3]-2*c3*M[2]+2*c7*M[5]+2*c5*M[1])*M[3]+c8*((2*M[3]/M[1])^c0*M[1]^2-2*2^c0*(M[3]/M[1])^c0*M[2])*(c2^(2*c0)+4^c0*(M[3]/M[1])^(2*c0)+2*2^c0*c2^c0*(M[3]/M[1])^c0)*M[1]*M[3]+1/2*c8*(M[3]/M[1])^c0*(c2^c0+(2*M[3]/M[1])^c0)*(-(2*c2)^c0*M[3]-(4*M[3]/M[1])^c0*M[3]-2*c0*2^(2*c0)*(M[3]/M[1])^c0*M[2]*M[3]+2*c0*2^(2*c0)*(M[3]/M[1])^c0*M[5]*M[1])*M[1]+1/2*c8*(2*M[3]/M[1])^c0*M[1]^2*(c2^(2*c0)+4^c0*(M[3]/M[1])^(2*c0)+2*2^c0*c2^c0*(M[3]/M[1])^c0)*M[3]+c0*c8*2^c0*(M[3]/M[1])^c0*(M[2]*M[3]-M[5]*M[1])*(c2^(2*c0)+4^c0*(M[3]/M[1])^(2*c0)+2*2^c0*c2^c0*(M[3]/M[1])^c0)*M[1])/((c2^c0+2^c0*(M[3]/M[1])^c0)^2*(c2^(2*c0)+2^(2*c0)*(M[3]/M[1])^(2*c0)+2*2^c0*c2^c0*(M[3]/M[1])^c0)^2*M[3])
    # Total Mass
    dM[3] = c4*c5+c1*M[1]-c3*M[3]-c6*M[3]
    # M^2
    dM[4] = c4*c5+c5*c4^2+c1*M[1]+c6*M[3]-2*c3*M[4]-2*c6*M[4]+2*c1*M[5]+c3*M[3]^2/M[1]+2*c4*c5*M[3]
    # N*M
    dM[5] = ((c2^c0+(2*M[3]/M[1])^c0)*(c2^(2*c0)+4^c0*(M[3]/M[1])^(2*c0)+2^(1+c0)*c2^c0*(M[3]/M[1])^c0)*(c4*c5+c3*M[3]+c7*M[4]+c5*M[3]+c1*M[2]-c6*M[5]-2*c3*M[5]+c4*c5*M[1])*M[3]+1/2*c8*(M[3]/M[1])^c0*(c2^c0+(2*M[3]/M[1])^c0)*((2*c2)^c0*M[5]*M[3]+(4*M[3]/M[1])^c0*M[5]*M[3]+c0*(2*c2)^c0*M[4]*M[1]+c0*(4*M[3]/M[1])^c0*M[1]^2*M[4]-c0*(2*c2)^c0*M[5]*M[3]-c0*(4*M[3]/M[1])^c0*M[5]*M[1]*M[3])+1/2*c8*((2*M[3]/M[1])^c0*M[1]*M[3]-2^(1+c0)*(M[3]/M[1])^c0*M[5])*(c2^(2*c0)+4^c0*(M[3]/M[1])^(2*c0)+2^(1+c0)*c2^c0*(M[3]/M[1])^c0)*M[1]*M[3]+1/2*c0*c8*(2*M[3]/M[1])^c0*(M[5]*M[3]-M[4]*M[1])*(c2^(2*c0)+4^c0*(M[3]/M[1])^(2*c0)+2^(1+c0)*c2^c0*(M[3]/M[1])^c0)*M[1])/((c2^c0+2^c0*(M[3]/M[1])^c0)*(c2^(2*c0)+2^(2*c0)*(M[3]/M[1])^(2*c0)+2*2^c0*c2^c0*(M[3]/M[1])^c0)*M[3])
    return
end

##################### IntakeExitCoagulation(MichaelisMenten)FragmentationBirthDeath

@export function IECmmFBD(; 
                            kI=5.0, kE=0.1, 
                            kC=5e-3, kF=5e-3, 
                            kb=10.0, kd=0.1, 
                            λ=10.0, 
                            kM = 10,
                            Ω=1.0, Ωc=1.0,
                            )
    kI, kE, kC, kF, kb, kd, λ, kM, Ω, Ωc = float.( (kI, kE, kC, kF, kb, kd, λ, kM, Ω, Ωc) )
    kI *= Ω; kC /= Ω*Ωc^2
    kb *= Ωc; kF /= Ωc
    kM *= Ωc # Right?
    p = Dict(:kI=>kI, :kE=>kE, :kC=>kC, :kF=>kF, :kb=>kb, :kd=>kd, :λ=>λ, :kM=>kM,
                :Ω=>Ω, :Ωc=>Ωc,
                )
    ssaSys = getIECmmFBDSSASystem(; kI=kI, kE=kE, kC=kC, kF=kF, kb=kb, kd=kd, λ=λ, kM=kM)
    return Model(p, Ω, Ωc, IECpFBD_initial, IECmmFBD_ODEs, ssaSys)
end

function getIECmmFBDSSASystem(;
                            kI = 0.0, kE = 0.0,  # Intake/Exit rates for cells
                            kC = 0.0, kF = 0.0,  # Coag/Frag rates for cells
                            kb = 0.0, kd = 0.0,  # Birth/Death rates for X1
                            λ = 0,  # Parameter of the poisson distrib on intake
                            kM = 0, # Michaelis-Menten constant
                            )
    S = Sim.System("IECmmFBD", 1, # X1
            [:N =>[0], # Number of compartments
             :M¹ =>[1], # M¹
             :M² =>[2], # M²
            ]
            )

    # cells' reaction network
    prodX1 = Sim.new_chemical_reaction_class([1], kb)
    prodX1.H = (n::SystemState, Mom::Moments) -> Mom[1]
    prodX1.fast_sample_reactants! = fast_sample_uniform_cell

    deathX1 = Sim.new_chemical_reaction_class([-1], kd)
    deathX1.H = (n::SystemState, Mom::Moments) -> Mom[2]
    # deathX1.g = (xc::Compartments, Mom::Moments) -> xc[1][1]
    deathX1.fast_sample_reactants! = fast_sample_mass_x1

    # Compartment reactions
    cellIntake = Sim.TransitionClass(0, 1, kI)
    cellIntake.H = (n::SystemState, Mom::Moments) -> 1
    # This is how the output compartment (yc) of the transition looks like
    cellIntake.pi = function(yc::Compartments, xc::Compartments)
                        yc[1][1] = rand(Poisson(λ))
                    end

    cellExit = Sim.TransitionClass(1, 0, kE) # This is a cell death
    cellExit.H = (n::SystemState, Mom::Moments) -> Mom[1] # Depends on num cells
    cellExit.fast_sample_reactants! = fast_sample_uniform_cell

    coagulation = Sim.TransitionClass(2, 1, kC)
    coagulation.g = (xc::Compartments, Mom::Moments) -> (xc[1][1]+xc[2][1])/(xc[1][1]+xc[2][1]+kM)
    coagulation.pi = function(yc::Compartments, xc::Compartments)
                            yc[1][:] .= xc[1][:] .+ xc[2][:]
                        end

    fragmentation = Sim.TransitionClass(1, 2, kF)
    fragmentation.H = (n::SystemState, Mom::Moments) -> Mom[2]
    fragmentation.fast_sample_reactants! = fast_sample_mass_x1
    fragmentation.pi = function(yc::Compartments, xc::Compartments)
                        yc[1][1] = rand(0:xc[1][1])
                        yc[2][1] = xc[1][1] - yc[1][1]
                    end

    Sim.add_transition_class(S, prodX1, deathX1, 
        cellIntake, cellExit, coagulation, fragmentation)

    return S
end

function IECmmFBD_ODEs(dM, M, parameters, t)
    c5 = parameters[:λ] # λ
    c0 = parameters[:kM] # kM
    c1 = parameters[:kC] # kC
    c7 = parameters[:kE] # kE
    c6 = parameters[:kF] # kF
    c3 = parameters[:kI] # kI
    c4 = parameters[:kb] # kb
    c2 = parameters[:kd] # kd
    # Number of Compartments (N)
    dM[1] = (2*c6*M[3]^2+2*c3*M[3]+c0*c3*M[1]+c1*M[1]*M[3]-c0*c7*M[1]^2-c1*M[1]^2*M[3]-2*c7*M[1]*M[3]+c0*c6*M[1]*M[3])/(2*M[3]+c0*M[1])
    # N^2
    dM[2] = (4*c6*M[3]^3+4*c3*M[3]^2+c7*c0^2*M[1]^3+c3*c0^2*M[1]^2-8*c7*M[3]^2*M[2]-2*c1*M[3]^2*M[1]+2*c1*M[1]^2*M[3]^2+2*c3*c0^2*M[1]^3+4*c1*M[1]^3*M[3]^2+4*c1*M[3]^2*M[2]+4*c7*M[3]^2*M[1]+8*c6*M[3]^2*M[5]+8*c3*M[3]^2*M[1]+c0*c1*M[1]^3*M[3]+c6*c0^2*M[1]^2*M[3]-c0*c1*M[1]^2*M[3]-8*c1*M[3]^2*M[2]*M[1]-2*c0*c1*M[1]^3*M[5]-2*c7*c0^2*M[1]^2*M[2]+2*c0*c1*M[1]^2*M[5]+2*c0*c1*M[1]^4*M[3]+2*c6*c0^2*M[1]^2*M[5]+4*c0*c7*M[1]^2*M[3]+4*c0*c6*M[3]^2*M[1]+4*c0*c3*M[1]*M[3]+8*c0*c3*M[1]^2*M[3]-8*c0*c7*M[2]*M[1]*M[3]-2*c0*c1*M[1]^2*M[2]*M[3]+8*c0*c6*M[5]*M[1]*M[3])/(4*M[3]^2+c0^2*M[1]^2+4*c0*M[1]*M[3])
    # Total Mass
    dM[3] = c5*c3+c4*M[1]-c7*M[3]-c2*M[3]
    # M^2
    dM[4] = c5*c3+c3*c5^2+c4*M[1]+c2*M[3]-2*c7*M[4]-2*c2*M[4]+2*c4*M[5]+c7*M[3]^2/M[1]+2*c5*c3*M[3]
    # N*M
    dM[5] = (c1*(2*M[3]+c0*M[1])*(4*M[3]^2+c0*(4*M[3]+c0*M[1])*M[1])*(2*M[1]^2*M[3]^3+2*M[3]^2*M[5]+c0*M[1]^2*M[4]-4*M[3]^2*M[5]*M[1])+(2*M[3]+c0*M[1])*(4*M[3]^2+c0*(4*M[3]+c0*M[1])*M[1])*(4*M[3]^2+c0^2*M[1]^2+4*c0*M[1]*M[3])*(c5*c3+c7*M[3]+c6*M[4]+c3*M[3]+c4*M[2]-c2*M[5]-2*c7*M[5]+c5*c3*M[1])+c1*(4*M[3]^2+c0*(4*M[3]+c0*M[1])*M[1])*(4*M[3]^2+c0^2*M[1]^2+4*c0*M[1]*M[3])*(M[3]^2*M[1]-M[4]*M[1]-M[5]*M[3])*M[1]+2*c1*(2*M[3]+c0*M[1])*(4*M[3]^2+c0^2*M[1]^2+4*c0*M[1]*M[3])*(M[4]*M[1]+M[5]*M[3]-M[3]^2*M[1])*M[1]*M[3])/((2*M[3]+c0*M[1])*(4*M[3]^2+c0*(4*M[3]+c0*M[1])*M[1])*(4*M[3]^2+c0^2*M[1]^2+4*c0*M[1]*M[3]))
    return
end

##################### IntakeExitCoagulation(loglog)FragmentationBirthDeath

@export function IECllFBD(; 
                            kI=5.0, kE=0.1, 
                            # kC=5e-6, kF=5e-2, 
                            kC=5e-4, kF=5e-3, 
                            kb=10.0, kd=0.1, 
                            λ=10.0, 
                            Ω=1.0, Ωc=1.0,
                            )
    kI, kE, kC, kF, kb, kd, λ, Ω, Ωc = float.( (kI, kE, kC, kF, kb, kd, λ, Ω, Ωc) )
    kI *= Ω; kC /= Ω*Ωc^2
    kb *= Ωc; kF /= Ωc
    p = Dict(:kI=>kI, :kE=>kE, :kC=>kC, :kF=>kF, :kb=>kb, :kd=>kd, :λ=>λ, 
                :Ω=>Ω, :Ωc=>Ωc,
                )
    ssaSys = getIECllFBDSSASystem(; kI=kI, kE=kE, kC=kC, kF=kF, kb=kb, kd=kd, λ=λ)
    return Model(p, Ω, Ωc, IECpFBD_initial, IECllFBD_ODEs, ssaSys)
end

function getIECllFBDSSASystem(;
                            kI = 0.0, kE = 0.0,  # Intake/Exit rates for cells
                            kC = 0.0, kF = 0.0,  # Coag/Frag rates for cells
                            kb = 0.0, kd = 0.0,  # Birth/Death rates for X1
                            λ = 0,  # Parameter of the poisson distrib on intake
                            )
    S = Sim.System("IECllFBD", 1, # X1
            [:N =>[0], # Number of compartments
             :M¹ =>[1], # M¹
             :M² =>[2], # M²
            ]
            )

    # cells' reaction network
    prodX1 = Sim.new_chemical_reaction_class([1], kb)
    prodX1.H = (n::SystemState, Mom::Moments) -> Mom[1]
    prodX1.fast_sample_reactants! = fast_sample_uniform_cell

    deathX1 = Sim.new_chemical_reaction_class([-1], kd)
    deathX1.H = (n::SystemState, Mom::Moments) -> Mom[2]
    deathX1.fast_sample_reactants! = fast_sample_mass_x1

    # Compartment reactions
    cellIntake = Sim.TransitionClass(0, 1, kI)
    cellIntake.H = (n::SystemState, Mom::Moments) -> 1
    # This is how the output compartment (yc) of the transition looks like
    cellIntake.pi = function(yc::Compartments, xc::Compartments)
                        yc[1][1] = rand(Poisson(λ))
                    end

    cellExit = Sim.TransitionClass(1, 0, kE) # This is a cell death
    cellExit.H = (n::SystemState, Mom::Moments) -> Mom[1] # Depends on num cells
    cellExit.fast_sample_reactants! = fast_sample_uniform_cell

    coagulation = Sim.TransitionClass(2, 1, kC)
    coagulation.g = (xc::Compartments, Mom::Moments) -> log(1+xc[1][1]+xc[2][1])
    coagulation.pi = function(yc::Compartments, xc::Compartments)
                            yc[1][:] .= xc[1][:] .+ xc[2][:]
                        end

    fragmentation = Sim.TransitionClass(1, 2, kF)
    fragmentation.H = (n::SystemState, Mom::Moments) -> Mom[2]
    fragmentation.fast_sample_reactants! = fast_sample_mass_x1
    fragmentation.pi = function(yc::Compartments, xc::Compartments)
                        yc[1][1] = rand(0:xc[1][1])
                        yc[2][1] = xc[1][1] - yc[1][1]
                    end

    Sim.add_transition_class(S, prodX1, deathX1, 
        cellIntake, cellExit, coagulation, fragmentation)

    return S
end

function IECllFBD_ODEs(dM, M, parameters, t)
    c2 = parameters[:λ] # λ
    c3 = parameters[:kC] # kC
    c0 = parameters[:kE] # kE
    c5 = parameters[:kF] # kF
    c6 = parameters[:kI] # kI
    c4 = parameters[:kb] # kb
    c1 = parameters[:kd] # kd
    # Number of Compartments (N)
    dM[1] = c6+c5*M[3]-c0*M[1]+1/2*c3*M[1]*log(1+2*M[3]/M[1])-1/2*c3*M[1]^2*log(1+2*M[3]/M[1])
    # N^2
    dM[2] = 1/2*((2*M[3]+M[1])*(2*c6-4*c0*M[2]+2*c0*M[1]+2*c5*M[3]+4*c5*M[5]+4*c6*M[1]+c3*M[1]^2*log((2*M[3]+M[1])/M[1])+2*c3*M[1]^3*log((2*M[3]+M[1])/M[1])-4*c3*M[2]*M[1]*log((2*M[3]+M[1])/M[1]))+2*c3*(-2*M[1]^2*M[5]-2*M[2]*M[3]+2*M[5]*M[1]+M[2]*M[1]*log((2*M[3]+M[1])/M[1])-M[1]*M[3]*log((2*M[3]+M[1])/M[1])+2*M[2]*M[1]*M[3]+2*M[2]*M[3]*log((2*M[3]+M[1])/M[1]))-c3*M[1]^2*log((2*M[3]+M[1])/M[1]))/(2*M[3]+M[1])
    # Total Mass
    dM[3] = c2*c6+c4*M[1]-c0*M[3]-c1*M[3]
    # M^2
    dM[4] = c2*c6+c6*c2^2+c4*M[1]+c1*M[3]-2*c0*M[4]-2*c1*M[4]+2*c4*M[5]+c0*M[3]^2/M[1]+2*c2*c6*M[3]
    # N*M
    dM[5] = 1/2*((2*M[3]+M[1])*(-4*c0*M[5]-2*c1*M[5]+2*c2*c6+2*c0*M[3]+2*c5*M[4]+2*c6*M[3]+2*c4*M[2]+2*c2*c6*M[1]+c3*M[1]^2*M[3]*log((2*M[3]+M[1])/M[1])-2*c3*M[5]*M[1]*log((2*M[3]+M[1])/M[1]))+2*c3*(M[4]*M[1]-M[1]^2*M[4]-M[5]*M[3]+M[5]*M[1]*M[3]+M[5]*M[3]*log((2*M[3]+M[1])/M[1]))+c3*M[5]*M[1]*log((2*M[3]+M[1])/M[1]))/(2*M[3]+M[1])
    return
end

##################### IntakeExitCoagulation²FragmentationBirthDeath

@export function IECpqFBD(; 
                            kI=5.0, kE=0.1, 
                            # kC=5e-6, kF=5e-2, 
                            # kC=5e-5, kF=5e-3, 
                            kC=5e-5, kF=3*5e-2, 
                            kb=10.0, kd=0.1, 
                            λ=10.0, 
                            Ω=1.0, Ωc=1.0,
                            )
    kI, kE, kC, kF, kb, kd, λ, Ω, Ωc = float.( (kI, kE, kC, kF, kb, kd, λ, Ω, Ωc) )
    kI *= Ω; kC /= Ω*Ωc^2
    kb *= Ωc; kF /= Ωc
    p = Dict(:kI=>kI, :kE=>kE, :kC=>kC, :kF=>kF, :kb=>kb, :kd=>kd, :λ=>λ, 
                :Ω=>Ω, :Ωc=>Ωc,
                )
    ssaSys = getIECpqFBDSSASystem(; kI=kI, kE=kE, kC=kC, kF=kF, kb=kb, kd=kd, λ=λ)
    return Model(p, Ω, Ωc, IECpFBD_initial, IECpqFBD_ODEs, ssaSys)
end

function getIECpqFBDSSASystem(;
                            kI = 0.0, kE = 0.0,  # Intake/Exit rates for cells
                            kC = 0.0, kF = 0.0,  # Coag/Frag rates for cells
                            kb = 0.0, kd = 0.0,  # Birth/Death rates for X1
                            λ = 0,  # Parameter of the poisson distrib on intake
                            )
    S = Sim.System("IECpqFBD", 1, # X1
            [:N =>[0], # Number of compartments
             :M¹ =>[1], # M¹
             :M² =>[2], # M²
            ]
            )

    # cells' reaction network
    prodX1 = Sim.new_chemical_reaction_class([1], kb)
    prodX1.H = (n::SystemState, Mom::Moments) -> Mom[1]
    prodX1.fast_sample_reactants! = fast_sample_uniform_cell

    deathX1 = Sim.new_chemical_reaction_class([-1], kd)
    deathX1.H = (n::SystemState, Mom::Moments) -> Mom[2]
    deathX1.fast_sample_reactants! = fast_sample_mass_x1

    # Compartment reactions
    cellIntake = Sim.TransitionClass(0, 1, kI)
    cellIntake.H = (n::SystemState, Mom::Moments) -> 1
    # This is how the output compartment (yc) of the transition looks like
    cellIntake.pi = function(yc::Compartments, xc::Compartments)
                        yc[1][1] = rand(Poisson(λ))
                    end

    cellExit = Sim.TransitionClass(1, 0, kE) # This is a cell death
    cellExit.H = (n::SystemState, Mom::Moments) -> Mom[1] # Depends on num cells
    cellExit.fast_sample_reactants! = fast_sample_uniform_cell

    coagulation = Sim.TransitionClass(2, 1, kC)
    # coagulation.H = (n::SystemState, Mom::Moments) -> Mom[3]*(Mom[1]-1) # NM2-M2
    coagulation.H = (n::SystemState, Mom::Moments) -> Mom[3]*(Mom[1]-2) + Mom[2]^2 # M²(N-2) + (M¹)²
    coagulation.g = (xc::Compartments, Mom::Moments) -> (xc[1][1]+xc[2][1])^2
    coagulation.pi = function(yc::Compartments, xc::Compartments)
                            yc[1][:] .= xc[1][:] .+ xc[2][:]
                        end

    fragmentation = Sim.TransitionClass(1, 2, kF)
    fragmentation.H = (n::SystemState, Mom::Moments) -> Mom[2]
    fragmentation.fast_sample_reactants! = fast_sample_mass_x1
    fragmentation.pi = function(yc::Compartments, xc::Compartments)
                        yc[1][1] = rand(0:xc[1][1])
                        yc[2][1] = xc[1][1] - yc[1][1]
                    end

    Sim.add_transition_class(S, prodX1, deathX1, 
        cellIntake, cellExit, coagulation, fragmentation)

    return S
end

function IECpqFBD_ODEs(dM, M, parameters, t)
    c6 = parameters[:λ] # λ
    c2 = parameters[:kC] # kC
    c1 = parameters[:kE] # kE
    c3 = parameters[:kF] # kF
    c0 = parameters[:kI] # kI
    c4 = parameters[:kb] # kb
    c5 = parameters[:kd] # kd
    # Number of Compartments (N)
    dM[1] = c0+c3*M[3]-c1*M[1]-2*c2*M[3]^2+2*c2*M[3]^2/M[1]
    # N^2
    dM[2] = (M[1]^2*(c0+c1*M[1]+c3*M[3]-2*c1*M[2]+2*c2*M[3]^2+2*c3*M[5]+2*c0*M[1]-8*c2*M[5]*M[3]+4*c2*M[3]^2*M[1])-4*c2*M[3]^2*M[2]+2*c2*(-M[3]+4*M[5])*M[1]*M[3])/M[1]^2
    # Total Mass
    dM[3] = c6*c0+c4*M[1]-c1*M[3]-c5*M[3]
    # M^2
    dM[4] = c6*c0+c0*c6^2+c4*M[1]+c5*M[3]-2*c1*M[4]-2*c5*M[4]+2*c4*M[5]+c1*M[3]^2/M[1]+2*c6*c0*M[3]
    # N*M
    dM[5] = c6*c0+c1*M[3]+c3*M[4]+c0*M[3]+c4*M[2]-c5*M[5]-2*c1*M[5]+2*c2*M[3]^3+c6*c0*M[1]-4*c2*M[4]*M[3]-2*c2*M[3]^2*M[5]/M[1]^2+4*c2*M[4]*M[3]/M[1]
    return
end

function IECpqFBD_ODEs_partiallyClosed(dM, M, parameters, t)
    c4 = parameters[:λ] # λ
    c1 = parameters[:kC] # kC
    c6 = parameters[:kE] # kE
    c2 = parameters[:kF] # kF
    c5 = parameters[:kI] # kI
    c0 = parameters[:kb] # kb
    c3 = parameters[:kd] # kd
    # Number of Compartments (N)
    dM[1] = (M[1]^2*(c5+c2*M[3]-c6*M[1])+2*c1*M[3]^2*M[2]+2*c1*(-2*M[5]+M[3])*M[1]*M[3])/M[1]^2
    # N^2
    dM[2] = (M[1]^3*(c5+c6*M[1]+c2*M[3]-2*c6*M[2]+2*c2*M[5]+2*c5*M[1])-4*c1*M[3]^2*(M[1]^2-2*M[2])*M[2]+2*c1*M[1]^2*(-M[3]+6*M[5])*M[3]+2*c1*(-8*M[5]-3*M[3]+4*M[1]*M[3])*M[2]*M[1]*M[3])/M[1]^3
    # Total Mass
    dM[3] = c4*c5+c0*M[1]-c6*M[3]-c3*M[3]
    # M^2
    dM[4] = c4*c5+c5*c4^2+c0*M[1]+c3*M[3]-2*c6*M[4]-2*c3*M[4]+2*c0*M[5]+c6*M[3]^2/M[1]+2*c4*c5*M[3]
    # N*M
    dM[5] = (M[1]^3*(c4*c5+c6*M[3]+c2*M[4]+c5*M[3]+c0*M[2]-c3*M[5]-2*c6*M[5]+c4*c5*M[1])-2*c1*M[3]^2*M[5]*M[1]+2*c1*M[3]^2*(2*M[5]-M[1]*M[3])*M[2]+4*c1*M[1]^2*(-2*M[5]+M[1]*M[3]+M[3])*M[4])/M[1]^3
    return
end

##################### IntakeExitCoagulation²FragmentationBirthDeath

@export function IECpFBD(; kI=5.0, kE=0.1, kC=0.005/5, kF=0.005, kb=10.0, kd=5*0.1, λ=10.0, 
                            Ω=1.0, Ωc=1.0,
                            )
    kI, kE, kC, kF, kb, kd, λ, Ω, Ωc = float.( (kI, kE, kC, kF, kb, kd, λ, Ω, Ωc) )
    kI *= Ω; kC /= Ω*Ωc
    kb *= Ωc; kF /= Ωc
    p = Dict(:kI=>kI, :kE=>kE, :kC=>kC, :kF=>kF, :kb=>kb, :kd=>kd, :λ=>λ, 
                :Ω=>Ω, :Ωc=>Ωc,
                )
    ssaSys = getIECpFBDSSASystem(; kI=kI, kE=kE, kC=kC, kF=kF, kb=kb, kd=kd, λ=λ)
    return Model(p, Ω, Ωc, IECpFBD_initial, IECpFBD_ODEs, ssaSys)
end

function getIECpFBDSSASystem(;
                            kI = 0.0, kE = 0.0,  # Intake/Exit rates for cells
                            kC = 0.0, kF = 0.0,  # Coag/Frag rates for cells
                            kb = 0.0, kd = 0.0,  # Birth/Death rates for X1
                            λ = 0,  # Parameter of the poisson distrib on intake
                            )
    S = Sim.System("IECpFBD", 1, # X1
            [:N =>[0], # Number of compartments
             :M¹ =>[1], # M¹
             :M² =>[2], # M²
            ]
            )

    # cells' reaction network
    prodX1 = Sim.new_chemical_reaction_class([1], kb)
    prodX1.H = (n::SystemState, Mom::Moments) -> Mom[1]
    prodX1.fast_sample_reactants! = fast_sample_uniform_cell

    deathX1 = Sim.new_chemical_reaction_class([-1], kd)
    deathX1.H = (n::SystemState, Mom::Moments) -> Mom[2]
    deathX1.fast_sample_reactants! = fast_sample_mass_x1

    # Compartment reactions
    cellIntake = Sim.TransitionClass(0, 1, kI)
    cellIntake.H = (n::SystemState, Mom::Moments) -> 1
    # This is how the output compartment (yc) of the transition looks like
    cellIntake.pi = function(yc::Compartments, xc::Compartments)
                        yc[1][1] = rand(Poisson(λ))
                    end
    # cell_division.fast_sample_reactants! = fast_sample_cell_div

    cellExit = Sim.TransitionClass(1, 0, kE) # This is a cell death
    cellExit.H = (n::SystemState, Mom::Moments) -> Mom[1] # Depends on num cells
    cellExit.fast_sample_reactants! = fast_sample_uniform_cell

    coagulation = Sim.TransitionClass(2, 1, kC)
    coagulation.H = (n::SystemState, Mom::Moments) -> Mom[2]*(Mom[1]-1) # NM1-M1
    coagulation.fast_sample_reactants! = 
        (r_indices::Vector{Int64}, n::SystemState, Mom::Moments) -> 
            fast_sample_generic_binary(r_indices, n, Mom, (x,y)->x[1]+y[1], ()->coagulation.H(n, Mom))
    coagulation.pi = function(yc::Compartments, xc::Compartments)
                            yc[1][:] .= xc[1][:] .+ xc[2][:]
                        end

    fragmentation = Sim.TransitionClass(1, 2, kF)
    fragmentation.H = (n::SystemState, Mom::Moments) -> Mom[2]
    fragmentation.fast_sample_reactants! = fast_sample_mass_x1
    fragmentation.pi = function(yc::Compartments, xc::Compartments)
                        yc[1][1] = rand(0:xc[1][1])
                        yc[2][1] = xc[1][1] - yc[1][1]
                    end

    Sim.add_transition_class(S, prodX1, deathX1, 
        cellIntake, cellExit, coagulation, fragmentation)

    return S
end

function IECpFBD_ODEs(dM, M, parameters, t)
    c5 = parameters[:λ] # λ
    c2 = parameters[:kC] # kC
    c4 = parameters[:kE] # kE
    c3 = parameters[:kF] # kF
    c0 = parameters[:kI] # kI
    c6 = parameters[:kb] # kb
    c1 = parameters[:kd] # kd
    # Number of Compartments (N)
    dM[1] = c0+c2*M[3]+c3*M[3]-c4*M[1]-c2*M[1]*M[3]
    # N^2
    dM[2] = c0+c4*M[1]+c3*M[3]-c2*M[3]-2*c4*M[2]+2*c2*M[5]+2*c3*M[5]+2*c0*M[1]+c2*M[1]*M[3]-2*c2*M[2]*M[3]-2*c2*M[5]*M[1]+2*c2*M[1]^2*M[3]
    # Total Mass
    dM[3] = c5*c0+c6*M[1]-c4*M[3]-c1*M[3]
    # M^2
    dM[4] = c5*c0+c0*c5^2+c6*M[1]+c1*M[3]-2*c4*M[4]-2*c1*M[4]+2*c6*M[5]+c4*M[3]^2/M[1]+2*c5*c0*M[3]
    # N*M
    dM[5] = c5*c0+c2*M[4]+c4*M[3]+c3*M[4]+c0*M[3]+c6*M[2]-c1*M[5]-2*c4*M[5]+c5*c0*M[1]+c2*M[3]^2*M[1]-c2*M[4]*M[1]-c2*M[5]*M[3]
    return
end

# initialize expected moments vector
function IECpFBD_initial(N0, Mpc0)
    M0 = N0*Mpc0
    M = zeros(5)
    # Number of Compartments (N)
    M[1] = N0 # initial value for Moment(0,), please specify!
    # N^2
    M[2] = M[1]^2
    # Total Mass
    M[3] = M0 # initial value for Moment(1,), please specify!
    # M^2
    M[4] = M[3]^2
    # N*M
    M[5] = M[1]*M[3]
    return M
end

##################### IntakeExitCoagulationFragmentation²BirthDeath

@export function IECFqBD(;  kI=5.0, kE=0.1, 
                            kC=1e-3, kF=5e-3, 
                            kb=10.0, kd=5*0.1, 
                            λ=10.0, 
                            Ω=1.0, Ωc=1.0,
                            )
    kI, kE, kC, kF, kb, kd, λ, Ω, Ωc = float.( (kI, kE, kC, kF, kb, kd, λ, Ω, Ωc) )
    kI *= Ω; kC /= Ω
    kb *= Ωc; kF /= Ωc^2
    p = Dict(:kI=>kI, :kE=>kE, :kC=>kC, :kF=>kF, :kb=>kb, :kd=>kd, :λ=>λ, 
                :Ω=>Ω, :Ωc=>Ωc,
                )
    ssaSys = getIECFqBDSSASystem(; kI=kI, kE=kE, kC=kC, kF=kF, kb=kb, kd=kd, λ=λ)
    return Model(p, Ω, Ωc, IECFqBD_initial, IECFqBD_ODEs, ssaSys)
end

function getIECFqBDSSASystem(;
                            kI = 0.0, kE = 0.0,  # Intake/Exit rates for cells
                            kC = 0.0, kF = 0.0,  # Coag/Frag rates for cells
                            kb = 0.0, kd = 0.0,  # Birth/Death rates for X1
                            λ = 0,  # Parameter of the poisson distrib on intake
                            )
    S = Sim.System("IECFqBD", 1, # X1
            [:N =>[0], # Number of compartments
             :M¹ =>[1], # M¹
             :M² =>[2], # M²
            ]
            )

    # cells' reaction network
    prodX1 = Sim.new_chemical_reaction_class([1], kb)
    prodX1.H = (n::SystemState, Mom::Moments) -> Mom[1]
    prodX1.fast_sample_reactants! = fast_sample_uniform_cell

    deathX1 = Sim.new_chemical_reaction_class([-1], kd)
    deathX1.H = (n::SystemState, Mom::Moments) -> Mom[2]
    deathX1.fast_sample_reactants! = fast_sample_mass_x1

    # Compartment reactions
    cellIntake = Sim.TransitionClass(0, 1, kI)
    cellIntake.H = (n::SystemState, Mom::Moments) -> 1
    # This is how the output compartment (yc) of the transition looks like
    cellIntake.pi = function(yc::Compartments, xc::Compartments)
                        yc[1][1] = rand(Poisson(λ))
                    end
    # cell_division.fast_sample_reactants! = fast_sample_cell_div

    cellExit = Sim.TransitionClass(1, 0, kE) # This is a cell death
    cellExit.H = (n::SystemState, Mom::Moments) -> Mom[1] # Depends on num cells
    cellExit.fast_sample_reactants! = fast_sample_uniform_cell

    coagulation = Sim.TransitionClass(2, 1, kC)
    coagulation.H = (n::SystemState, Mom::Moments) -> Mom[1]*(Mom[1]-1)/2
    coagulation.fast_sample_reactants! = fast_sample_uniform_2cells
    coagulation.pi = function(yc::Compartments, xc::Compartments)
                            yc[1][:] .= xc[1][:] .+ xc[2][:]
                        end

    fragmentation = Sim.TransitionClass(1, 2, kF)
    fragmentation.H = (n::SystemState, Mom::Moments) -> div(Mom[3]-Mom[2], 2)
    fragmentation.fast_sample_reactants! = fast_sample_x1_square
    fragmentation.pi = function(yc::Compartments, xc::Compartments)
                        yc[1][1] = rand(0:xc[1][1])
                        yc[2][1] = xc[1][1] - yc[1][1]
                    end

    Sim.add_transition_class(S, prodX1, deathX1, 
        cellIntake, cellExit, coagulation, fragmentation)

    return S
end

function IECFqBD_ODEs(dM, M, parameters, t)
    c3 = parameters[:λ] # λ
    c6 = parameters[:kC] # kC
    c0 = parameters[:kE] # kE
    c2 = parameters[:kF] # kF
    c4 = parameters[:kI] # kI
    c5 = parameters[:kb] # kb
    c1 = parameters[:kd] # kd
    # Number of Compartments (N)
    dM[1] = c4+1/2*c6*M[1]-c0*M[1]-1/2*c6*M[1]^2-1/2*c2*M[3]+1/2*c2*M[3]^2/M[1]
    # N^2
    dM[2] = c4+c6*M[1]^3+c6*M[2]+c0*M[1]+1/2*c6*M[1]^2-c2*M[5]-2*c0*M[2]+2*c4*M[1]-1/2*c6*M[1]-1/2*c2*M[3]+1/2*c2*M[3]^2/M[1]-2*c6*M[2]*M[1]-c2*M[3]^2*M[2]/M[1]^2+2*c2*M[5]*M[3]/M[1]
    # Total Mass
    dM[3] = c3*c4+c5*M[1]-c0*M[3]-c1*M[3]
    # M^2
    dM[4] = c3*c4+c4*c3^2+c5*M[1]+c1*M[3]-2*c0*M[4]-2*c1*M[4]+2*c5*M[5]+c0*M[3]^2/M[1]+2*c3*c4*M[3]
    # N*M
    dM[5] = c3*c4+c0*M[3]+c4*M[3]+c5*M[2]+1/2*c6*M[5]-c1*M[5]-2*c0*M[5]-1/2*c2*M[4]+c3*c4*M[1]+1/2*c6*M[1]^2*M[3]-c6*M[5]*M[1]+c2*M[4]*M[3]/M[1]-1/2*c2*M[3]^2*M[5]/M[1]^2
    return
end

# initialize expected moments vector
function IECFqBD_initial(N0, Mpc0)
    M0 = N0*Mpc0
    M = zeros(5)
    # Number of Compartments (N)
    M[1] = N0 # initial value for Moment(0,), please specify!
    # N^2
    M[2] = M[1]^2
    # Total Mass
    M[3] = M0 # initial value for Moment(1,), please specify!
    # M^2
    M[4] = M[3]^2
    # N*M
    M[5] = M[1]*M[3]
    return M
end

##################### IntakeExitCoagulationFragmentationBirthDeath³

@export function IECFBDc(; kI=5.0, kE=0.1, kC=0.005, kF=0.005, kb=10.0, kd=0.1, λ=10.0, 
                            Ω=1.0, Ωc=1.0,
                            )
    kI, kE, kC, kF, kb, kd, λ, Ω, Ωc = float.( (kI, kE, kC, kF, kb, kd, λ, Ω, Ωc) )
    kI *= Ω; kC /= Ω
    kb *= Ωc; kd /= Ωc^2; kF /= Ωc
    p = Dict(:kI=>kI, :kE=>kE, :kC=>kC, :kF=>kF, :kb=>kb, :kd=>kd, :λ=>λ, 
                :Ω=>Ω, :Ωc=>Ωc,
                )
    ssaSys = getIECFBDcSSASystem(; kI=kI, kE=kE, kC=kC, kF=kF, kb=kb, kd=kd, λ=λ)
    return Model(p, Ω, Ωc, IECFBDq_initial, IECFBDc_ODEs, ssaSys)
end

function getIECFBDcSSASystem(;
                            kI = 0.0, kE = 0.0,  # Intake/Exit rates for cells
                            kC = 0.0, kF = 0.0,  # Coag/Frag rates for cells
                            kb = 0.0, kd = 0.0,  # Birth/Death rates for X1
                            λ = 0,  # Parameter of the poisson distrib on intake
                            )
    S = Sim.System("IECFBDc", 1, # X1
            [:N =>[0], # Number of compartments
             :M¹ =>[1], # M¹
             :M² =>[2], # M²
             :M³ =>[3], # M³
            ]
            )

    # cells' reaction network
    prodX1 = Sim.new_chemical_reaction_class([1], kb)
    prodX1.H = (n::SystemState, Mom::Moments) -> Mom[1]
    prodX1.fast_sample_reactants! = fast_sample_uniform_cell

    deathX1 = Sim.new_chemical_reaction_class([-3], kd)
    deathX1.H = (n::SystemState, Mom::Moments) -> div(Mom[4] - 3*Mom[3] + 2*Mom[2], 6)
    deathX1.fast_sample_reactants! = fast_sample_x1_cube

    # Compartment reactions
    cellIntake = Sim.TransitionClass(0, 1, kI)
    cellIntake.H = (n::SystemState, Mom::Moments) -> 1
    # This is how the output compartment (yc) of the transition looks like
    cellIntake.pi = function(yc::Compartments, xc::Compartments)
                        yc[1][1] = rand(Poisson(λ))
                    end
    # cell_division.fast_sample_reactants! = fast_sample_cell_div

    cellExit = Sim.TransitionClass(1, 0, kE) # This is a cell death
    cellExit.H = (n::SystemState, Mom::Moments) -> Mom[1] # Depends on num cells
    cellExit.fast_sample_reactants! = fast_sample_uniform_cell

    coagulation = Sim.TransitionClass(2, 1, kC)
    coagulation.H = (n::SystemState, Mom::Moments) -> Mom[1]*(Mom[1]-1)/2
    coagulation.fast_sample_reactants! = fast_sample_uniform_2cells
    coagulation.pi = function(yc::Compartments, xc::Compartments)
                            yc[1][:] .= xc[1][:] .+ xc[2][:]
                        end

    fragmentation = Sim.TransitionClass(1, 2, kF)
    fragmentation.H = (n::SystemState, Mom::Moments) -> Mom[2]
    fragmentation.fast_sample_reactants! = fast_sample_mass_x1
    fragmentation.pi = function(yc::Compartments, xc::Compartments)
                        yc[1][1] = rand(0:xc[1][1])
                        yc[2][1] = xc[1][1] - yc[1][1]
                    end

    Sim.add_transition_class(S, prodX1, deathX1, 
        cellIntake, cellExit, coagulation, fragmentation)

    return S
end

function IECFBDc_ODEs(dM, M, parameters, t)
    c0 = parameters[:kC] # k_C, please specify!
    c5 = parameters[:kC] # kC
    c6 = parameters[:kE] # kE
    c2 = parameters[:kF] # kF
    c1 = parameters[:kI] # kI
    c4 = parameters[:kb] # kb
    c3 = parameters[:kd] # kd
    # Number of Compartments (N)
    dM[1] = c1+c2*M[3]+1/2*c5*M[1]-c6*M[1]-1/2*c5*M[1]^2
    # N^2
    dM[2] = c1+c5*M[1]^3+c5*M[2]+c6*M[1]+c2*M[3]+1/2*c5*M[1]^2-2*c6*M[2]+2*c2*M[5]+2*c1*M[1]-1/2*c5*M[1]-2*c5*M[2]*M[1]
    # Total Mass
    dM[3] = c0*c1+c4*M[1]-c6*M[3]-c3*M[3]-1/2*c3*M[3]^3/M[1]^2+3/2*c3*M[3]^2/M[1]
    # M^2
    dM[4] = 1/2*(2*M[1]^3*(c0*c1+c1*c0^2+c4*M[1]-2*c6*M[4]-2*c3*M[4]+2*c4*M[5]+3*c3*M[3]+2*c0*c1*M[3])+M[1]^2*(-9*c3*M[3]+2*c6*M[3]+12*c3*M[4])*M[3]+4*c3*M[3]^3*M[5]+3*c3*M[3]^2*(-2*M[4]-2*M[5]+M[3])*M[1])/M[1]^3
    # N*M
    dM[5] = 1/2*(M[1]^3*(c5*M[5]-4*c6*M[5]-2*c3*M[5]+2*c0*c1+2*c6*M[3]+2*c2*M[4]+2*c1*M[3]+2*c4*M[2]+c5*M[1]^2*M[3]-2*c5*M[5]*M[1]+2*c0*c1*M[1])+2*c3*M[3]^3*M[2]-3*c3*M[3]^2*(M[2]+M[5])*M[1]+6*c3*M[1]^2*M[5]*M[3])/M[1]^3
    return
end

##################### IntakeExitCoagulationFragmentationBirthDeath²

@export function IECFBDq(; kI=5.0, kE=0.1, kC=0.005, kF=0.005, kb=10.0, kd=0.1, λ=10.0, 
                            Ω=1.0, Ωc=1.0,
                            )
    kI, kE, kC, kF, kb, kd, λ, Ω, Ωc = float.( (kI, kE, kC, kF, kb, kd, λ, Ω, Ωc) )
    kI *= Ω; kC /= Ω
    kb *= Ωc; kd /= Ωc; kF /= Ωc
    p = Dict(:kI=>kI, :kE=>kE, :kC=>kC, :kF=>kF, :kb=>kb, :kd=>kd, :λ=>λ, 
                :Ω=>Ω, :Ωc=>Ωc,
                )
    ssaSys = getIECFBDqSSASystem(; kI=kI, kE=kE, kC=kC, kF=kF, kb=kb, kd=kd, λ=λ)
    return Model(p, Ω, Ωc, IECFBDq_initial, IECFBDq_ODEs, ssaSys)
end

function getIECFBDqSSASystem(;
                            kI = 0.0, kE = 0.0,  # Intake/Exit rates for cells
                            kC = 0.0, kF = 0.0,  # Coag/Frag rates for cells
                            kb = 0.0, kd = 0.0,  # Birth/Death rates for X1
                            λ = 0,  # Parameter of the poisson distrib on intake
                            )
    S = Sim.System("IECFBDq", 1, # X1
            [:N =>[0], # Number of compartments
             :M¹ =>[1], # M¹
             :M² =>[2], # M²
            ]
            )

    # cells' reaction network
    prodX1 = Sim.new_chemical_reaction_class([1], kb)
    prodX1.H = (n::SystemState, Mom::Moments) -> Mom[1]
    prodX1.fast_sample_reactants! = fast_sample_uniform_cell

    deathX1 = Sim.new_chemical_reaction_class([-2], kd)
    deathX1.H = (n::SystemState, Mom::Moments) -> div(Mom[3]-Mom[2], 2)
    deathX1.fast_sample_reactants! = fast_sample_x1_square

    # Compartment reactions
    cellIntake = Sim.TransitionClass(0, 1, kI)
    cellIntake.H = (n::SystemState, Mom::Moments) -> 1
    # This is how the output compartment (yc) of the transition looks like
    cellIntake.pi = function(yc::Compartments, xc::Compartments)
                        yc[1][1] = rand(Poisson(λ))
                    end
    # cell_division.fast_sample_reactants! = fast_sample_cell_div

    cellExit = Sim.TransitionClass(1, 0, kE) # This is a cell death
    cellExit.H = (n::SystemState, Mom::Moments) -> Mom[1] # Depends on num cells
    cellExit.fast_sample_reactants! = fast_sample_uniform_cell

    coagulation = Sim.TransitionClass(2, 1, kC)
    coagulation.H = (n::SystemState, Mom::Moments) -> Mom[1]*(Mom[1]-1)/2
    coagulation.fast_sample_reactants! = fast_sample_uniform_2cells
    coagulation.pi = function(yc::Compartments, xc::Compartments)
                            yc[1][:] .= xc[1][:] .+ xc[2][:]
                        end

    fragmentation = Sim.TransitionClass(1, 2, kF)
    fragmentation.H = (n::SystemState, Mom::Moments) -> Mom[2]
    fragmentation.fast_sample_reactants! = fast_sample_mass_x1
    fragmentation.pi = function(yc::Compartments, xc::Compartments)
                        yc[1][1] = rand(0:xc[1][1])
                        yc[2][1] = xc[1][1] - yc[1][1]
                    end

    Sim.add_transition_class(S, prodX1, deathX1, 
        cellIntake, cellExit, coagulation, fragmentation)

    return S
end

function IECFBDq_ODEs(dM, M, parameters, t)
    c0 = parameters[:kC] # k_C, please specify!
    c1 = parameters[:kd] # k_d, please specify!
    c2 = parameters[:λ] # \lambda, please specify!
    c3 = parameters[:kI] # k_I, please specify!
    c4 = parameters[:kb] # k_b, please specify!
    c5 = parameters[:kE] # k_E, please specify!
    c6 = parameters[:kF] # k_F, please specify!
    # Number of Compartments (N)
    dM[1] = c3+c6*M[3]+1/2*c0*M[1]-c5*M[1]-1/2*c0*M[1]^2
    # N^2
    dM[2] = c3+c0*M[1]^3+c0*M[2]+c5*M[1]+c6*M[3]+1/2*c0*M[1]^2-2*c5*M[2]+2*c6*M[5]+2*c3*M[1]-1/2*c0*M[1]-2*c0*M[2]*M[1]
    # Total Mass
    dM[3] = c2*c3+c4*M[1]+c1*M[3]-c5*M[3]-c1*M[3]^2/M[1]
    # M^2
    dM[4] = (M[1]^2*(c2*c3+c3*c2^2+c4*M[1]-2*c5*M[4]-2*c1*M[3]+2*c4*M[5]+2*c1*M[4]+2*c2*c3*M[3])+(c5*M[3]-4*c1*M[4]+2*c1*M[3])*M[1]*M[3]+2*c1*M[3]^2*M[5])/M[1]^2
    # N*M
    dM[5] = c2*c3+c5*M[3]+c6*M[4]+c3*M[3]+c4*M[2]+c1*M[5]+1/2*c0*M[5]-2*c5*M[5]+c2*c3*M[1]+1/2*c0*M[1]^2*M[3]-c0*M[5]*M[1]+c1*M[3]^2*M[2]/M[1]^2-2*c1*M[5]*M[3]/M[1]
    return
end

# initialize expected moments vector
function IECFBDq_initial(N0, Mpc0)
    M0 = N0*Mpc0
    M = zeros(5)
    # Number of Compartments (N)
    M[1] = N0 # initial value for Moment(0,), please specify!
    # N^2
    M[2] = M[1]^2
    # Total Mass
    M[3] = M0 # initial value for Moment(1,), please specify!
    # M^2
    M[4] = M[3]^2
    # N*M
    M[5] = M[1]*M[3]
    return M
end

##################### IntakeExitCoagulationFragmentationBirthDeath

@export function IECFBD(; kI=5.0, kE=0.1, kC=0.005, kF=0.005, kb=10.0, kd=5*0.1, λ=10.0, 
                            Ω=1.0, Ωc=1.0,
                            )
    kI, kE, kC, kF, kb, kd, λ, Ω, Ωc = float.( (kI, kE, kC, kF, kb, kd, λ, Ω, Ωc) )
    kI *= Ω; kC /= Ω
    kb *= Ωc; kF /= Ωc
    p = Dict(:kI=>kI, :kE=>kE, :kC=>kC, :kF=>kF, :kb=>kb, :kd=>kd, :λ=>λ, 
                :Ω=>Ω, :Ωc=>Ωc,
                )
    ssaSys = getIECFBDSSASystem(; kI=kI, kE=kE, kC=kC, kF=kF, kb=kb, kd=kd, λ=λ)
    return Model(p, Ω, Ωc, IECFBD_initial, IECFBD_ODEs, ssaSys)
end

function getIECFBDSSASystem(;
                            kI = 0.0, kE = 0.0,  # Intake/Exit rates for cells
                            kC = 0.0, kF = 0.0,  # Coag/Frag rates for cells
                            kb = 0.0, kd = 0.0,  # Birth/Death rates for X1
                            λ = 0,  # Parameter of the poisson distrib on intake
                            )
    S = Sim.System("IECFBD", 1, # X1
            [:N =>[0], # Number of compartments
             :M¹ =>[1], # M¹
             :M² =>[2], # M²
            ]
            )

    # cells' reaction network
    prodX1 = Sim.new_chemical_reaction_class([1], kb)
    prodX1.H = (n::SystemState, Mom::Moments) -> Mom[1]
    prodX1.fast_sample_reactants! = fast_sample_uniform_cell

    deathX1 = Sim.new_chemical_reaction_class([-1], kd)
    deathX1.H = (n::SystemState, Mom::Moments) -> Mom[2]
    deathX1.fast_sample_reactants! = fast_sample_mass_x1

    # Compartment reactions
    cellIntake = Sim.TransitionClass(0, 1, kI)
    cellIntake.H = (n::SystemState, Mom::Moments) -> 1
    # This is how the output compartment (yc) of the transition looks like
    cellIntake.pi = function(yc::Compartments, xc::Compartments)
                        yc[1][1] = rand(Poisson(λ))
                    end
    # cell_division.fast_sample_reactants! = fast_sample_cell_div

    cellExit = Sim.TransitionClass(1, 0, kE) # This is a cell death
    cellExit.H = (n::SystemState, Mom::Moments) -> Mom[1] # Depends on num cells
    cellExit.fast_sample_reactants! = fast_sample_uniform_cell

    coagulation = Sim.TransitionClass(2, 1, kC)
    coagulation.H = (n::SystemState, Mom::Moments) -> Mom[1]*(Mom[1]-1)/2
    coagulation.fast_sample_reactants! = fast_sample_uniform_2cells
    coagulation.pi = function(yc::Compartments, xc::Compartments)
                            yc[1][:] .= xc[1][:] .+ xc[2][:]
                        end

    fragmentation = Sim.TransitionClass(1, 2, kF)
    fragmentation.H = (n::SystemState, Mom::Moments) -> Mom[2]
    fragmentation.fast_sample_reactants! = fast_sample_mass_x1
    fragmentation.pi = function(yc::Compartments, xc::Compartments)
                        yc[1][1] = rand(0:xc[1][1])
                        yc[2][1] = xc[1][1] - yc[1][1]
                    end

    Sim.add_transition_class(S, prodX1, deathX1, 
        cellIntake, cellExit, coagulation, fragmentation)

    return S
end

function IECFBD_ODEs(dM, M, parameters, t)
    c6 = parameters[:λ] # λ
    c5 = parameters[:kC] # kC
    c0 = parameters[:kE] # kE
    c1 = parameters[:kF] # kF
    c2 = parameters[:kI] # kI
    c4 = parameters[:kb] # kb
    c3 = parameters[:kd] # kd
    # Number of Compartments (N)
    dM[1] = c2+c1*M[3]+1/2*c5*M[1]-c0*M[1]-1/2*c5*M[1]^2
    # N^2
    dM[2] = c2+c5*M[1]^3+c5*M[2]+c0*M[1]+c1*M[3]+1/2*c5*M[1]^2-2*c0*M[2]+2*c1*M[5]+2*c2*M[1]-1/2*c5*M[1]-2*c5*M[2]*M[1]
    # Total Mass
    dM[3] = c6*c2+c4*M[1]-c0*M[3]-c3*M[3]
    # M^2
    dM[4] = c6*c2+c2*c6^2+c4*M[1]+c3*M[3]-2*c0*M[4]-2*c3*M[4]+2*c4*M[5]+c0*M[3]^2/M[1]+2*c6*c2*M[3]
    # N*M
    dM[5] = c6*c2+c0*M[3]+c1*M[4]+c2*M[3]+c4*M[2]+1/2*c5*M[5]-c3*M[5]-2*c0*M[5]+c6*c2*M[1]+1/2*c5*M[1]^2*M[3]-c5*M[5]*M[1]
    return
end

# initialize expected moments vector
function IECFBD_initial(N0, Mpc0)
    M0 = N0*Mpc0
    M = zeros(5)
    # Number of Compartments (N)
    M[1] = N0 # initial value for Moment(0,), please specify!
    # N^2
    M[2] = M[1]^2
    # Total Mass
    M[3] = M0 # initial value for Moment(1,), please specify!
    # M^2
    M[4] = M[3]^2
    # N*M
    M[5] = M[1]*M[3]
    return M
end

#####################

@export function nBDq(; kI=5.0, kE=0.1, kb=10.0, kd=0.01, λ=10.0, Ω=1.0, Ωc=1.0)
    kI, kE, kb, kd, λ, Ω, Ωc = float.( (kI, kE, kb, kd, λ, Ω, Ωc) )
    kI *= Ω
    kb *= Ωc; kd /= Ωc
    p = (kI, kE, kb, kd, λ, λ, 1.0, 1.0)
    ssaSys = getNBDqSSASystem(; kI=kI, kE=kE, kb=kb, kd=kd, λ=λ)
    return Model(p, Ω, Ωc, NDBqInit, NBDqODE, ssaSys)
end

NDBqInit(N, Mpc) = [N, N^2, N*Mpc, (N*Mpc)^2, N*N*Mpc, N*Mpc*Mpc]


function getNBDqSSASystem(;
                            kI = 0.0, kE = 0.0,  # Intake/Exit rates for cells
                            kb = 0.0, kd = 0.0,  # Birth/Death rates for X1
                            λ = 0,  # Parameter of the poisson distrib on intake
                            )
    S = Sim.System("NBDq", 1, # X1
            [:N =>[0], # Number of compartments
             :M¹ =>[1], # M¹
             :M² =>[2], # M²
            ]
            )

    # cells' reaction network
    prodX1 = Sim.new_chemical_reaction_class([1], kb)
    prodX1.H = (n::SystemState, Mom::Moments) -> Mom[1]
    prodX1.fast_sample_reactants! = fast_sample_uniform_cell

    deathX1 = Sim.new_chemical_reaction_class([-2], kd)
    deathX1.H = (n::SystemState, Mom::Moments) -> div(Mom[3]-Mom[2], 2)
    deathX1.fast_sample_reactants! = fast_sample_x1_square

    # Compartment reactions
    cellIntake = Sim.TransitionClass(0, 1, kI)
    cellIntake.H = (n::SystemState, Mom::Moments) -> 1
    # This is how the output compartment (yc) of the transition looks like
    cellIntake.pi = function(yc::Compartments, xc::Compartments)
                        yc[1][1] = rand(Poisson(λ))
                    end
    # cell_division.fast_sample_reactants! = fast_sample_cell_div

    cellExit = Sim.TransitionClass(1, 0, kE) # This is a cell death
    cellExit.H = (n::SystemState, Mom::Moments) -> Mom[1] # Depends on num cells
    cellExit.fast_sample_reactants! = fast_sample_uniform_cell

    Sim.add_transition_class(S, prodX1, deathX1, cellIntake, cellExit)

    return S
end

@export function NBDqODE(du, u, p, t)
    # All the following are implied to be in average
    N, N², M1, M1², NM1, M2 = u
    kI, kE, kb, kd, μI, σ²I = p

    # @show (M1², NM1) #debug

    # This is by considering x(x-1)/2 as propensity
    dN   = kI - kE*N
    dN²  = kI*(1 + 2*N) + kE*(N - 2*N²)
    dM1  = kI*μI - kE*M1 + kb*N - kd*( (M1^2 / N) - M1 )
    dM1² = ( 
           kI*(σ²I + μI^2 + 2*μI*M1)
         # - kE*( 2*M1² - (M1^2 / N)) # Approximation of M2
         - kE*( 2*M1² - M2) # Actually using M2
         + kb*(N + 2*NM1)
         # + kd*( (1 - 2*M1/N)*M1² + (2 + NM1/N)*(M1^2)/N - 2*M1 )
         # + kd*(
         #      -( (2 * M1 * M1² / N) - (M1^2 * NM1 / N^2) )
         #      + M1²
         #      + 2*M2 # Actually using M2
         #      # + 2*(M1^2 / N) # Approx M2
         #      -2*M1
         #  )
         + kd*(
                -4*M1²*M1/N
                +2*NM1*(M1^2)/(N^2)
                +2*M1²
                +2*(M1^2)/N
                -2*M1
            )
        )
    dNM1 = ( kI*( (N+1)*μI + M1 )
         - kE*(2*NM1 - M1)
         + kb*N²
         # + kd*( 2* M1^2 * N²/ N^2 - 4*M1*NM1/N + 2*NM1 )
         +kd*( -2*M1*NM1/N + N²*(M1^2)/(N^2) + NM1 )
         )
    dM2  = ( 
           kI*(σ²I + μI)
         - kE*M2
         + kb*(N + 2*M1)
         + kd*( (2 - 4*M1/N)*M2 + (2*(M1^2)/(N^2) + 4*M1/N - 2)*M1 - 2*(M1^2)/N ) 
         # + kd*(
         #      -2*(M1^3 / N^2)
         #      +4*M2
         #      -2*M1
         #  )
        )

    # u .= [ N, N², M1, M1², NM1, M2 ]
    du .= [ dN, dN², dM1, dM1², dNM1, dM2 ]
end

### SUPPORTING FUNCTIONS FOR EFFICIENT SIMULATION ###
function fast_sample_first(r_indices::Vector{Int64}, n::SystemState, Mom::Moments)
    r_indices[1] = 1
end

function fast_sample_uniform_cell(r_indices::Vector{Int64}, n::SystemState, Mom::Moments)
    r_indices[1] = rand(1:Mom[1])
end

function fast_sample_uniform_2cells(r_indices::Vector{Int64}, n::SystemState, Mom::Moments)
    r_indices[1] = rand(1:Mom[1])
    r_indices[2] = rand(1:Mom[1])
    while r_indices[1] == r_indices[2]
        r_indices[2] = rand(1:Mom[1])
    end
    sort!(r_indices) # This is necessary!
end

function fast_sample_mass_x1(r_indices::Vector{Int64}, n::SystemState, Mom::Moments)
    N = Mom[1]
    H = Mom[2]
    rv = rand()*H
    r_indices[1] = 1
    val = 1.0*n[1,1]
    while val < rv
        r_indices[1] += 1
        val += n[1, r_indices[1]]
    end
    @assert r_indices[1]<=N """
        FATAL: Reactant ($(r_indices[1])) out of range ($N)!
        H = $H
        rv = $rv
        val = $val
        fast_sample_mass_x1
        """
end

# interaction_square(x) = x<=1 ? 0 : div(x*(x-1),2)
interaction_square(x) = x*(x-1)/2
interaction_cube(x) = x*(x-1)*(x-2)/6

function _getTotalPropensity(N, n, interaction)
    val = 0.0
    for i=1:N
        val += interaction(n[1, i])
    end
    return val
end

function fast_sample_x1_square(r_indices::Vector{Int64}, n::SystemState, Mom::Moments)
    N = Mom[1]
    H = div(Mom[3]-Mom[2], 2)
    rv = rand()*H
    r_indices[1] = 1
    val = 1.0*interaction_square(n[1,1]) # Layout of n is [species, cell]
    while val < rv
        r_indices[1] += 1
        x = n[1, r_indices[1]]
        @assert x >= 0 "FATAL: The state ($x) of cell ($(r_indices[1])/$(N)) must be NON-NEGATIVE!"
        val += interaction_square(x)
    end
    @assert r_indices[1]<=N """
        FATAL: Reactant ($(r_indices[1])) out of range ($N)!
        H = $H
        rv = $rv
        val = $val
        fast_sample_x1_square
        """
end

function fast_sample_x1_cube(r_indices::Vector{Int64}, n::SystemState, Mom::Moments)
    N = Mom[1]
    H = div(Mom[4] - 3*Mom[3] + 2*Mom[2], 6)
    rv = rand()*H
    r_indices[1] = 1
    val = 1.0*interaction_cube(n[1,1]) # Layout of n is [species, cell]
    while val < rv
        r_indices[1] += 1
        x = n[1, r_indices[1]]
        @assert x >= 0 "FATAL: The state ($x) of cell ($(r_indices[1])/$(N)) must be NON-NEGATIVE!"
        val += interaction_cube(x)
    end
    @assert r_indices[1]<=N """
        FATAL: Reactant ($(r_indices[1])) out of range ($N)!
        H = $H
        rv = $rv
        val = $val
        fast_sample_x1_cube
        """
end

#eof
